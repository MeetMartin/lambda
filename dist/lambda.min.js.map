{"version":3,"sources":["webpack://L/webpack/universalModuleDefinition","webpack://L/./node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack://L/./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","webpack://L/./node_modules/@babel/runtime/helpers/defineProperty.js","webpack://L/./node_modules/@babel/runtime/helpers/iterableToArray.js","webpack://L/./node_modules/@babel/runtime/helpers/nonIterableSpread.js","webpack://L/./node_modules/@babel/runtime/helpers/toConsumableArray.js","webpack://L/./node_modules/@babel/runtime/helpers/typeof.js","webpack://L/./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack://L/./src/arity.js","webpack://L/./src/conditional.js","webpack://L/./src/core.js","webpack://L/./src/utils.js","webpack://L/./src/string.js","webpack://L/./src/list.js","webpack://L/./src/Case.js","webpack://L/./src/Maybe.js","webpack://L/./src/Either.js","webpack://L/./src/SyncEffect.js","webpack://L/./src/AsyncEffect.js","webpack://L/webpack/bootstrap","webpack://L/webpack/startup","webpack://L/webpack/runtime/compat get default export","webpack://L/webpack/runtime/define property getters","webpack://L/webpack/runtime/hasOwnProperty shorthand","webpack://L/webpack/runtime/make namespace object"],"names":["root","factory","exports","module","define","amd","this","arr","len","length","i","arr2","Array","arrayLikeToArray","isArray","obj","key","value","Object","defineProperty","enumerable","configurable","writable","iter","Symbol","iterator","from","TypeError","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread","_typeof","constructor","prototype","o","minLen","n","toString","call","slice","name","test","nary","fn","args","reduce","accumulator","current","isEqual","a","b","isNotEqual","isDeepEqual","deepInspect","isNotDeepEqual","isTrue","isFalse","isGreaterThan","isLessThan","isAtLeast","isAtMost","isTypeOf","typeOf","isNotTypeOf","isString","isNotString","isBoolean","isNotBoolean","isNull","isNotNull","isUndefined","isNotUndefined","isNumber","isNotNumber","isObject","isNotObject","isNotArray","isFunction","isNotFunction","isLength","lengthOf","isNotLength","isEmpty","anything","getOwnPropertyNames","isNotEmpty","isZero","isNotZero","isNothing","isJust","identity","and","boolFns","every","boolFn","or","some","compose","fns","reduceRight","v","f","pipe","map","mapper","list","flatMap","functor","liftA2","ap1","ap2","ap","liftA3","ap3","concat","undefined","merge","sources","acc","c","includes","indexOf","minusOneToUndefined","lastIndexOf","memoize","memory","passThrough","memo","log","console","spy","inspectFunction","String","inspectArray","join","inspectString","inspectObject","inspect","k","keysOf","trim","string","testRegEx","regex","substr","limit","start","firstLetterOf","lastLetterOf","startsWith","substring","endsWith","repeat","count","replace","replacement","search","split","lowerCaseOf","toLowerCase","upperCaseOf","toUpperCase","initial","reducer","filter","checker","filterMap","push","find","findIndex","separator","keys","entriesOf","entries","everyOf","end","someOf","sort","compare","sortAlphabetically","sortAlphabeticallyZA","sortNumerically","sortNumerically21","headOf","tailOf","initOf","lastOf","groupBy","Case","of","match","getCase","get","Map","result","Maybe","Nothing","Just","maybe","error","onJust","functorMaybe","Either","Success","Failure","try","e","message","isFailure","isSuccess","either","onFailure","onSuccess","functorEither","SyncEffect","trigger","getSyncEffect","AsyncEffect","getAsyncEffect","reject","resolve","ofPromise","promise","then","Promise","x","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","getter","__esModule","d","definition","prop","hasOwnProperty","r","toStringTag"],"mappings":"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","file":"lambda.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"L\"] = factory();\n\telse\n\t\troot[\"L\"] = factory();\n})(this, function() {\nreturn ","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nmodule.exports = _arrayLikeToArray;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}\n\nmodule.exports = _arrayWithoutHoles;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nmodule.exports = _nonIterableSpread;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","var arrayLikeToArray = require(\"./arrayLikeToArray\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\n\nmodule.exports = _unsupportedIterableToArray;","/**\r\n * nary takes input of a curried function and allows it to be called both as curried and n-ary.\r\n *\r\n * @HindleyMilner nary :: (a -> b) -> a -> b\r\n *\r\n * @pure\r\n * @param {function} fn\r\n * @return {function}\r\n *\r\n * @example\r\n * import {nary} from '@7urtle/lambda';\r\n *\r\n * const fn1 = nary(a => b => a + b);\r\n * fn1('a')('b') === fn1('a', 'b'); // => true\r\n */\r\nexport const nary = fn =>\r\n    (...args) => args.length === 0\r\n        ? fn()\r\n        : args.reduce((accumulator, current) => accumulator(current), fn);","import {typeOf, lengthOf, deepInspect} from \"./utils\";\r\nimport {nary} from \"./arity\";\r\n\r\n/**\r\n * isEqual output is true if strict equality between a and b is true. isEqual output is always false for comparison\r\n * of objects and arrays.\r\n *\r\n * isEqual can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner isEqual :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @param {*} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isEqual} from '@7urtle/lambda';\r\n *\r\n * isEqual('something')('something'); // => true\r\n * isEqual('something')('something else'); // => false\r\n * isEqual(['a'])(['a']); // => false\r\n * isEqual({a : 'something'})({a : 'something'}); // => false\r\n * isEqual([])([]); // => false\r\n * isEqual([])([]); // => false\r\n *\r\n * // isEqual can be called both as a curried unary function or as a standard binary function\r\n * isEqual('something')('something') === isEqual('something', 'something');\r\n */\r\nexport const isEqual = nary(a => b => a === b);\r\n\r\n/**\r\n * isNotEqual output is true if strict equality between a and b is false. isNotEqual output is always true for\r\n * comparison of objects and arrays.\r\n *\r\n * isEqual can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner isNotEqual :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @param {*} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotEqual} from '@7urtle/lambda';\r\n *\r\n * isNotEqual('something')('something'); // => false\r\n * isNotEqual('something')('something else'); // => true\r\n * isNotEqual(['a'])(['a']); // => true\r\n * isNotEqual({a : 'something'})({a : 'something'}); // => true\r\n * isNotEqual([])([]); // => true\r\n * isNotEqual([])([]); // => true\r\n *\r\n * // isNotEqual can be called both as a curried unary function or as a standard binary function\r\n * isNotEqual('something')('something else') === isNotEqual('something', 'something else');\r\n */\r\nexport const isNotEqual = nary(a => b => a !== b);\r\n\r\n/**\r\n * isDeepEqual output is true if strict equality between the string conversion of a and the string conversion of b\r\n * is true including arrays and objects.\r\n *\r\n * isDeepEqual can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner isDeepEqual :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @param {*} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isDeepEqual} from '@7urtle/lambda';\r\n *\r\n * isDeepEqual('something')('something'); // => true\r\n * isDeepEqual('something')('something else'); // => false\r\n * isDeepEqual(['a'])(['a']); // => true\r\n * isDeepEqual({a : 'something'})({a : 'something'}); // => true\r\n * isDeepEqual([])([]); // => true\r\n * isDeepEqual([])([]); // => true\r\n *\r\n * // isDeepEqual can be called both as a curried unary function or as a standard binary function\r\n * isDeepEqual('something')('something') === isDeepEqual('something', 'something');\r\n */\r\nexport const isDeepEqual = nary(a => b => isEqual(deepInspect(a))(deepInspect(b)));\r\n\r\n/**\r\n * isNotDeepEqual output is true if strict equality between the string conversion of a and the string conversion of b\r\n * is false including arrays and objects.\r\n *\r\n * isNotDeepEqual can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner isNotDeepEqual :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @param {*} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotDeepEqual} from '@7urtle/lambda';\r\n *\r\n * isNotDeepEqual('something')('something'); // => false\r\n * isNotDeepEqual('something')('something else'); // => true\r\n * isNotDeepEqual(['a', 'b'])(['a']); // => true\r\n * isNotDeepEqual({a : 'something', b: c => c})({a : 'something'}); // => true\r\n * isNotDeepEqual([])([]); // => false\r\n * isNotDeepEqual([])([]); // => false\r\n *\r\n * // isNotDeepEqual can be called both as a curried unary function or as a standard binary function\r\n * isNotDeepEqual('something')('something else') === isNotDeepEqual('something', 'something else');\r\n */\r\nexport const isNotDeepEqual = nary(a => b => isNotEqual(deepInspect(a))(deepInspect(b)));\r\n\r\n/**\r\n * isTrue output is true if input is true.\r\n *\r\n * @HindleyMilner isTrue :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} anything\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isTrue} from '@7urtle/lambda';\r\n *\r\n * isTrue(true); // => true\r\n * isTrue(false); // => false\r\n */\r\nexport const isTrue = isEqual(true);\r\n\r\n/**\r\n * isFalse output is true if input is false.\r\n *\r\n * @HindleyMilner isFalse :: a -> Boolean\r\n *\r\n * @pure\r\n * @param {*} anything\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isFalse} from '@7urtle/lambda';\r\n *\r\n * isFalse(true); // => false\r\n * isFalse(false); // => true\r\n */\r\nexport const isFalse = isEqual(false);\r\n\r\n/**\r\n * isGreaterThan output is true if b is greater than a.\r\n *\r\n * isGreaterThan can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner isGreaterThan :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {number} a\r\n * @param {number} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isGreaterThan} from '@7urtle/lambda';\r\n *\r\n * isGreaterThan(1)(2); // => true\r\n * isGreaterThan(3)(2); // => false\r\n *\r\n * // isGreaterThan can be called both as a curried unary function or as a standard binary function\r\n * isGreaterThan(1)(2) === isGreaterThan(1, 2);\r\n */\r\nexport const isGreaterThan = nary(a => b => b > a);\r\n\r\n/**\r\n * isLessThan output is true if b is less than a.\r\n *\r\n * isLessThan can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner isLessThan :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {number} a\r\n * @param {number} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isLessThan} from '@7urtle/lambda';\r\n *\r\n * isLessThan(1)(2); // => false\r\n * isLessThan(3)(2); // => true\r\n *\r\n * // isLessThan can be called both as a curried unary function or as a standard binary function\r\n * isLessThan(3)(2) === isLessThan(3, 2);\r\n */\r\nexport const isLessThan = nary(a => b => b < a);\r\n\r\n/**\r\n * isAtLeast output is true if b is greater or equal to a.\r\n *\r\n * isAtLeast can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner isAtLeast :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {number} a\r\n * @param {number} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isAtLeast} from '@7urtle/lambda';\r\n *\r\n * isAtLeast(1)(2); // => true\r\n * isAtLeast(2)(2); // => true\r\n * isAtLeast(3)(2); // => false\r\n *\r\n * // isAtLeast can be called both as a curried unary function or as a standard binary function\r\n * isAtLeast(1)(2) === isAtLeast(1, 2);\r\n */\r\nexport const isAtLeast = nary(a => b => b >= a);\r\n\r\n/**\r\n * isAtMost output is true if b is less or equal to a.\r\n *\r\n * isAtMost can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner isAtMost :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {number} a\r\n * @param {number} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isAtMost} from '@7urtle/lambda';\r\n *\r\n * isAtMost(1)(2); // => false\r\n * isAtMost(2)(2); // => true\r\n * isAtMost(3)(2); // => true\r\n *\r\n * // isAtLeast can be called both as a curried unary function or as a standard binary function\r\n * isAtMost(3)(2) === isAtMost(31, 2);\r\n */\r\nexport const isAtMost = nary(a => b => b <= a);\r\n\r\n/**\r\n * isTypeOf output is true if b is a type of a.\r\n *\r\n * isTypeOf can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner isTypeOf :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @param {*} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isTypeOf} from '@7urtle/lambda';\r\n *\r\n * isTypeOf('number')(1); // => true\r\n * isTypeOf('string')(1); // => false\r\n *\r\n * // isTypeOf can be called both as a curried unary function or as a standard binary function\r\n * isTypeOf('number')(1) === isTypeOf('number', 1);\r\n */\r\nexport const isTypeOf = nary(a => b => isEqual(typeOf(b))(a));\r\n\r\n/**\r\n * isNotTypeOf output is true if b is not a type of a.\r\n *\r\n * isNotTypeOf can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner isNotTypeOf :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @param {*} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotTypeOf} from '@7urtle/lambda';\r\n *\r\n * isNotTypeOf('number')(1); // => false\r\n * isNotTypeOf('string')(1); // => true\r\n *\r\n * // isNotTypeOf can be called both as a curried unary function or as a standard binary function\r\n * isNotTypeOf('string')(1) === isNotTypeOf('string', 1);\r\n */\r\nexport const isNotTypeOf = nary(a => b => isNotEqual(typeOf(b))(a));\r\n\r\n/**\r\n * isString output is true if input is a string.\r\n *\r\n * @HindleyMilner isString :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isString} from '@7urtle/lambda';\r\n *\r\n * isString('string'); // => true\r\n * isString(1); // => false\r\n */\r\nexport const isString = isTypeOf('string');\r\n\r\n/**\r\n * isNotString output is true if input is not a string.\r\n *\r\n * @HindleyMilner isNotString :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotString} from '@7urtle/lambda';\r\n *\r\n * isNotString('string'); // => false\r\n * isNotString(1); // => true\r\n */\r\nexport const isNotString = isNotTypeOf('string');\r\n\r\n/**\r\n * isBoolean output is true if input is a boolean.\r\n *\r\n * @HindleyMilner isBoolean :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isBoolean} from '@7urtle/lambda';\r\n *\r\n * isBoolean(false); // => true\r\n * isBoolean(1); // => false\r\n */\r\nexport const isBoolean = isTypeOf('boolean');\r\n\r\n/**\r\n * isNotBoolean output is true if input is not a boolean.\r\n *\r\n * @HindleyMilner isNotBoolean :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotBoolean} from '@7urtle/lambda';\r\n *\r\n * isNotBoolean(false); // => false\r\n * isNotBoolean(1); // => true\r\n */\r\nexport const isNotBoolean = isNotTypeOf('boolean');\r\n\r\n/**\r\n * isNull output is true if input is a null.\r\n *\r\n * @HindleyMilner isNull :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNull} from '@7urtle/lambda';\r\n *\r\n * isNull(null); // => true\r\n * isNull(1); // => false\r\n */\r\nexport const isNull = isEqual(null);\r\n\r\n/**\r\n * isNotNull output is true if input is not a null.\r\n *\r\n * @HindleyMilner isNotNull :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotNull} from '@7urtle/lambda';\r\n *\r\n * isNotNull(null); // => false\r\n * isNotNull(1); // => true\r\n */\r\nexport const isNotNull = isNotEqual(null);\r\n\r\n/**\r\n * isUndefined output is true if input is an undefined.\r\n *\r\n * @HindleyMilner isUndefined :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isUndefined} from '@7urtle/lambda';\r\n *\r\n * isUndefined(undefined); // => true\r\n * isUndefined(1); // => false\r\n */\r\nexport const isUndefined = isTypeOf('undefined');\r\n\r\n/**\r\n * isNotUndefined output is true if input is not an undefined.\r\n *\r\n * @HindleyMilner isNotUndefined :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotUndefined} from '@7urtle/lambda';\r\n *\r\n * isNotUndefined(undefined); // => false\r\n * isNotUndefined(1); // => true\r\n */\r\nexport const isNotUndefined = isNotTypeOf('undefined');\r\n\r\n/**\r\n * isNumber output is true if input is a number.\r\n *\r\n * @HindleyMilner isNumber :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNumber} from '@7urtle/lambda';\r\n *\r\n * isNumber(1); // => true\r\n * isNumber('string'); // => false\r\n */\r\nexport const isNumber = isTypeOf('number');\r\n\r\n/**\r\n * isNotNumber output is true if input is not a number.\r\n *\r\n * @HindleyMilner isNotNumber :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotNumber} from '@7urtle/lambda';\r\n *\r\n * isNotNumber(1); // => false\r\n * isNotNumber('string'); // => true\r\n */\r\nexport const isNotNumber = isNotTypeOf('number');\r\n\r\n/**\r\n * isObject output is true if b is an object, array, or null.\r\n *\r\n * @HindleyMilner isObject :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isObject} from '@7urtle/lambda';\r\n *\r\n * isObject({}); // => true\r\n * isObject([]); // => true\r\n * isObject(null); // => true\r\n * isObject(1); // => false\r\n */\r\nexport const isObject = isTypeOf('object');\r\n\r\n/**\r\n * isNotObject output is true if input is not an object, array, or null.\r\n *\r\n * @HindleyMilner isNotObject :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotObject} from '@7urtle/lambda';\r\n *\r\n * isNotObject({}); // => false\r\n * isNotObject([]); // => false\r\n * isNotObject(null); // => false\r\n * isNotObject(1); // => true\r\n */\r\nexport const isNotObject = isNotTypeOf('object');\r\n\r\n/**\r\n * isArray output is true if input is an array.\r\n *\r\n * @HindleyMilner isArray :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isArray} from '@7urtle/lambda';\r\n *\r\n * isArray([]); // => true\r\n * isArray({}); // => false\r\n */\r\nexport const isArray = Array.isArray;\r\n\r\n/**\r\n * isNotArray output is true if input is not an array.\r\n *\r\n * @HindleyMilner isNotArray :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotArray} from '@7urtle/lambda';\r\n *\r\n * isNotArray([]); // => false\r\n * isNotArray({}); // => true\r\n */\r\nexport const isNotArray = a => !Array.isArray(a);\r\n\r\n/**\r\n * isFunction output is true if input is a function.\r\n *\r\n * @HindleyMilner isFunction :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isFunction} from '@7urtle/lambda';\r\n *\r\n * isFunction(() => null); // => true\r\n * isFunction(1); // => false\r\n */\r\nexport const isFunction = isTypeOf('function');\r\n\r\n/**\r\n * isNotFunction output is true if input is not a function.\r\n *\r\n * @HindleyMilner isNotFunction :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotFunction} from '@7urtle/lambda';\r\n *\r\n * isNotFunction(() => null); // => false\r\n * isNotFunction(1); // => true\r\n */\r\nexport const isNotFunction = isNotTypeOf('function');\r\n\r\n/**\r\n * isLength output is true if b is a length of a.\r\n *\r\n * @HindleyMilner isLength :: (string|array) -> b -> boolean\r\n *\r\n * @pure\r\n * @param {string|array} a\r\n * @param {number} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isLength} from '@7urtle/lambda';\r\n *\r\n * isLength(3)('abc'); // => true\r\n * isLength(3)([1,2,3]); // => true\r\n * isLength(3)('abc'); // => false\r\n */\r\nexport const isLength = nary(a => b => isEqual(lengthOf(b))(a));\r\n\r\n/**\r\n * isNotLength output is true if b is not a length of a.\r\n *\r\n * @HindleyMilner isNotLength :: (string|array) -> b -> boolean\r\n *\r\n * @pure\r\n * @param {string|array} a\r\n * @param {number} b\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotLength} from '@7urtle/lambda';\r\n *\r\n * isNotLength(3)('abc'); // => false\r\n * isNotLength(3)([1,2,3]); // => false\r\n * isNotLength(3)('abc'); // => true\r\n */\r\nexport const isNotLength = nary(a => b => !isLength(a)(b));\r\n\r\n/**\r\n * isEmpty output is true if input is an empty string, array, or object. Otherwise it is false.\r\n *\r\n * @HindleyMilner isEmpty :: (string|array) -> boolean\r\n *\r\n * @pure\r\n * @param {string|array|object} anything\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isEmpty} from '@7urtle/lambda';\r\n *\r\n * isEmpty(''); // => true\r\n * isEmpty([]); // => true\r\n * isEmpty({}); // => true\r\n * isEmpty('abc'); // => false\r\n */\r\nexport const isEmpty = anything =>\r\n    isLength(0)(anything) ||\r\n    (isObject(anything) ? isLength(0)(Object.getOwnPropertyNames(anything)) : false);\r\n\r\n/**\r\n * isNotEmpty output is false if input is an empty string, array, or object. Otherwise it is true.\r\n *\r\n * @HindleyMilner isNotEmpty :: (string|array) -> boolean\r\n *\r\n * @pure\r\n * @param {string|array|object} anything\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNotEmpty} from '@7urtle/lambda';\r\n *\r\n * isNotEmpty(''); // => false\r\n * isNotEmpty([]); // => false\r\n * isNotEmpty('abc'); // => true\r\n * isNotEmpty({}); => true\r\n */\r\nexport const isNotEmpty = anything => !isEmpty(anything);\r\n\r\n/**\r\n * isZero output is true if input is 0.\r\n *\r\n * @HindleyMilner isZero :: a -> boolean\r\n *\r\n * @pure\r\n * @param {number} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isZero} from '@7urtle/lambda';\r\n *\r\n * isZero(0); // => true\r\n * isZero(1); // => false\r\n */\r\nexport const isZero = isEqual(0);\r\n\r\n/**\r\n * isNotZero output is true if input is not 0.\r\n *\r\n * @HindleyMilner isNotZero :: a -> boolean\r\n *\r\n * @pure\r\n * @param {number} a\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isZero} from '@7urtle/lambda';\r\n *\r\n * isZero(0); // => false\r\n * isZero(1); // => true\r\n */\r\nexport const isNotZero = isNotEqual(0);\r\n\r\n/**\r\n * isNothing returns true if input is null, undefined or empty string or empty array or empty object.\r\n *\r\n * @HindleyMilner isNothing :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} anything\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isNothing} from '@7urtle/lambda';\r\n *\r\n * isNothing(null); // => true\r\n * isNothing(undefined); // => true\r\n * isNothing(''); // => true\r\n * isNothing([]); // => true\r\n * isNothing({}); // => true\r\n * isNothing('7urtle'); // => false\r\n */\r\nexport const isNothing = anything => isNull(anything) || isUndefined(anything) || isEmpty(anything);\r\n\r\n/**\r\n * isJust returns true if input is not null, undefined or empty string or empty array or empty object.\r\n *\r\n * @HindleyMilner isJust :: a -> boolean\r\n *\r\n * @pure\r\n * @param {*} anything\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {isJust} from '@7urtle/lambda';\r\n *\r\n * isJust(null); // => false\r\n * isJust(undefined); // => false\r\n * isJust(''); // => false\r\n * isJust([]); // => false\r\n * isJus({}); // => false\r\n * isJust('7urtle'); // => true\r\n */\r\nexport const isJust = anything => !isNothing(anything);","import { reduce, reduceRight, filterMap } from './list';\r\nimport { isString, isArray, isObject, isNotArray } from './conditional';\r\nimport { minusOneToUndefined, passThrough } from './utils';\r\nimport { nary } from \"./arity\";\r\n\r\n/**\r\n * identity is a function that simply passes its input to its output without changing it.\r\n *\r\n * @HindleyMilner identity :: a -> a\r\n *\r\n * @pure\r\n * @param {*} anything\r\n * @return {*}\r\n *\r\n * @example\r\n * import {identity} from '@7urtle/lambda';\r\n *\r\n * identity('anything');\r\n * // => anything\r\n */\r\nexport const identity = anything => anything;\r\n\r\n/**\r\n * and is a boolean-type function composition\r\n * where each boolean function is '&&'d together.\r\n * \r\n * The boolean functions may be entered in any order.\r\n * \r\n * and can be used together with or to encapsulate a predicate in a single function.\r\n * \r\n * @HindleyMilner and :: [(a -> boolean)] -> a -> boolean\r\n * \r\n * @pure\r\n * @param {function} boolFns\r\n * @param {*} anything\r\n * @return {*}\r\n * \r\n * @example\r\n * import {and, isGreaterThan, isLesssThan} from '@7urtle/lambda';\r\n * \r\n * const isEven = number => number % 2 === 0;\r\n * \r\n * const isSingleEvenDigit = and(isEven, isGreaterThan(-10), isLessThan(10));\r\n * isSingleEvenDigit(8)\r\n * // => true\r\n */\r\nexport const and = (...boolFns) => anything => boolFns.every(boolFn => boolFn(anything));\r\n\r\n/**\r\n * or is a boolean-type function composition\r\n * where each boolean function is '||'d together.\r\n * \r\n * The boolean functions may be entered in any order.\r\n * \r\n * or can be used together with and to encapsulate a predicate in a single function.\r\n * \r\n * @HindleyMilner and :: [(a -> boolean)] -> a -> boolean\r\n * \r\n * @pure\r\n * @param {function} boolFns\r\n * @param {*} anything\r\n * @return {*}\r\n * \r\n * @example\r\n * import {or} from '@7urtle/lambda';\r\n * \r\n * const isDivisibleBy = divisor => number => number % divisor === 0;\r\n * const isFizzBuzzNumber = or(isDivisibleBy(3), isDivisibleBy(5));\r\n * \r\n * isFizzBuzzNumber(15)\r\n * // => true\r\n */\r\nexport const or = (...boolFns) => anything => boolFns.some(boolFn => boolFn(anything));\r\n\r\n/**\r\n * compose is a right-to-left function composition\r\n * where each function receives input and hands over its output to the next function.\r\n *\r\n * compose executes functions in reverse order to pipe.\r\n *\r\n * compose(f,g)(x) is equivalent to f(g(x)).\r\n *\r\n * @HindleyMilner compose :: [(a -> b)] -> a -> b\r\n *\r\n * @pure\r\n * @param {function} fns\r\n * @param {*} anything\r\n * @return {*}\r\n *\r\n * @example\r\n * import {compose} from '@7urtle/lambda';\r\n *\r\n * const addA = a => a + 'A';\r\n * const addB = a => a + 'B';\r\n * const addAB = value => compose(addA, addB)(value);\r\n *\r\n * addAB('Order: ');\r\n * // => Order: BA\r\n */\r\nexport const compose = (...fns) => anything => reduceRight(anything)((v, f) => f(v))(fns);\r\n\r\n/**\r\n * pipe output is a left-to-right function composition\r\n * where each function receives input and hands over its output to the next function.\r\n *\r\n * pipe executes functions in reverse order to compose.\r\n *\r\n * pipe(f,g)(x) is equivalent to g(f(x)).\r\n *\r\n * @HindleyMilner pipe :: [(a -> b)] -> a -> b\r\n *\r\n * @pure\r\n * @param {function} fns\r\n * @param {*} anything\r\n * @return {*}\r\n *\r\n * @example\r\n * import {pipe} from '@7urtle/lambda';\r\n *\r\n * const addA = a => a + 'A';\r\n * const addB = a => a + 'B';\r\n * const addAB = value => pipe(addA, addB)(value);\r\n *\r\n * addAB('Order: ');\r\n * // => Order: AB\r\n */\r\nexport const pipe = (...fns) => anything => reduce(anything)((v, f) => f(v))(fns);\r\n\r\n/**\r\n * map executes mapper function over input array or monad and outputs the resulting array or monad.\r\n *\r\n * In case of monads, you should use map when you want to work with functors using functions\r\n * and functional composition rather than calling Functor.map.\r\n *\r\n * If you need to both filter and map over an array, consider using the filterMap function.\r\n *\r\n * map can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner map :: (a -> b) -> a -> b\r\n *\r\n * @param {function} fn\r\n * @param {array|functor} target\r\n * @return {array|functor}\r\n *\r\n * @example\r\n * import {map, Maybe, upperCaseOf} from '@7urtle/lambda';\r\n *\r\n * const mapper = a => a + 'm';\r\n * const list = ['a', 'b', 'c'];\r\n *\r\n * // the function mapper is applied to each member of the array\r\n * map(mapper)(list); // => ['am', 'bm', 'cm']\r\n *\r\n * // the function upperCaseOf is applied to the value of the functor\r\n * map(upperCaseOf)(Maybe.of('something')); // => Just('SOMETHING')\r\n *\r\n * // use of map equals the use of map on the functor\r\n * map(upperCaseOf)(Maybe.of('something')).value === Maybe.of('something').map(upperCaseOf).value;\r\n *\r\n * // map can be called both as a curried unary function or as a standard binary function\r\n * map(upperCaseOf)(Maybe.of('something')).value === map(upperCaseOf, Maybe.of('something')).value;\r\n */\r\nexport const map = nary(mapper => list => list.map(mapper));\r\n\r\n/**\r\n * flatMap maps function over inputted functor outputting resulting flattened functor.\r\n *\r\n * You should use flatMap when you want to work with functors using functions\r\n * and functional composition rather than calling flatMaps.\r\n *\r\n * The function can be called both as a unary flatMap(fn)(functor) and binary flatMap(fn, functor).\r\n *\r\n * @HindleyMilner flatMap :: (a -> Functor) -> Functor -> Functor\r\n *\r\n * @param {function} fn\r\n * @param {functor} functor\r\n * @return {functor}\r\n *\r\n * @example\r\n * import {flatMap, map, Maybe} from '@7urtle/lambda';\r\n *\r\n * const maybePlus2 = number => Maybe.of(number + 2);\r\n *\r\n * // the function maybePlus2 is applied to the value of the functor\r\n * flatMap(maybePlus2)(Maybe.of(3)); // => Just(5)\r\n * map(maybePlus2)(Maybe.of(3)); // => Just(Just(5))\r\n *\r\n * // use of flatMap equals the use of flatMap on the functor\r\n * flatMap(maybePlus2)(Maybe.of(3)).value === Maybe.of(3).flatMap(maybePlus2).value;\r\n *\r\n * // flatMap can be called both as a curried unary function or as a standard binary function\r\n * flatMap(maybePlus2)(Maybe.of(3)).value === flatMap(maybePlus2, Maybe.of(3)).value;\r\n */\r\nexport const flatMap = nary(fn => functor => functor.flatMap(fn));\r\n\r\n/**\r\n * liftA2 provides point-free way of writing calls over applicative functors and functions expecting 2 inputs. It\r\n * applies input function over both functors values providing a resulting functor.\r\n *\r\n * The function can be called both as a unary liftA2(fn)(functor)(functor) and ternary liftA2(fn, functor, functor).\r\n *\r\n * @HindleyMilner liftA2 (a -> b -> c) -> Applicative a -> Applicative b -> Applicative c\r\n *\r\n * @pure\r\n * @param {function} fn\r\n * @param {functor} ap1\r\n * @param {functor} ap2\r\n * @return {functor}\r\n *\r\n * @example\r\n * import {liftA2, Maybe} from '@7urtle/lambda';\r\n *\r\n * const add = a => b => a + b;\r\n *\r\n * // function add which expects two inputs is applied to the values of two applicative functors Maybe\r\n * // the result is a Maybe functor with the internal value 5\r\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)); // => Just(5)\r\n *\r\n * // an example of applying a function over a Maybe of undefined value to demonstrate continued safety of functors\r\n * liftA2(add)(Maybe.of(1))(Maybe.of(undefined)).isNothing(); // => true\r\n *\r\n * // liftA2 can be called both as a curried unary function or as a standard ternary function\r\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)).value === liftA2(add, Maybe.of(2), Maybe.of(3)).value;\r\n */\r\nexport const liftA2 = nary(fn => ap1 => ap2 => ap1.map(fn).ap(ap2));\r\n\r\n/**\r\n * liftA3 provides point-free way of writing calls over applicative functors and functions expecting 3 inputs. It\r\n * applies input function over input functors values providing a resulting functor.\r\n *\r\n * The function can be called both as a unary liftA3(fn)(functor)(functor)(functor) and quaternary liftA2(fn, functor, functor, functor).\r\n *\r\n * @HindleyMilner liftA3 (a -> b -> c -> d) -> Applicative a -> Applicative b -> Applicative c -> Applicative d\r\n *\r\n * @pure\r\n * @param {function} fn\r\n * @param {functor} ap1\r\n * @param {functor} ap2\r\n * @param {functor} ap3\r\n * @return {functor}\r\n *\r\n * @example\r\n * import {liftA3, Maybe} from '@7urtle/lambda';\r\n *\r\n * const add = a => b => c => a + b + c;\r\n *\r\n * // function add which expects three inputs is applied to the values of three applicative functors Maybe\r\n * // the result is a Maybe functor with the internal value 9\r\n * liftA3(add)(Maybe.of(2))(Maybe.of(3))(Maybe.of(4)); // => Just(9)\r\n *\r\n * // an example of applying a function over a Maybe of undefined value to demonstrate continued safety of functors\r\n * liftA3(add)(Maybe.of(1))(Maybe.of(2))(Maybe.of(undefined)).isNothing(); // => true\r\n *\r\n * // liftA3 can be called both as a curried unary function or as a standard quaternary function\r\n * liftA3(add)(Maybe.of(2))(Maybe.of(3))(Maybe.of(4)).value === liftA3(add, Maybe.of(2), Maybe.of(3), Maybe.of(4)).value;\r\n */\r\nexport const liftA3 = nary(fn => ap1 => ap2 => ap3 => ap1.map(fn).ap(ap2).ap(ap3));\r\n\r\n/**\r\n * contact outputs concatenated inputs of strings, arrays and shallow objects or outputs undefined for other types.\r\n *\r\n * concat can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner concat :: a -> a|boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @param {*} b\r\n * @return {*}\r\n *\r\n * @example\r\n * import {concat} from '@7urtle/lambda';\r\n *\r\n * concat('cd')('ab'); // => 'abcd'\r\n * concat([3, 4])([1,2]); // => [1, 2, 3, 4]\r\n * concat({here: {here: 'there'}})({hi: 'hello'}); // => {hi: 'hello', here: {here: 'there'}}\r\n * concat('cd')(1); // => undefined\r\n *\r\n * // concat can be called both as a curried unary function or as a standard binary function\r\n * concat('cd')('ab') === concat('cd', 'ab');\r\n */\r\nexport const concat = nary(a => b =>\r\n    isString(b) || isArray(b)\r\n        ? b.concat(a)\r\n        : isObject(b)\r\n            ? { ...b, ...a }\r\n            : undefined);\r\n\r\n/**\r\n * merge performs a deep merge on all input objects and arrays.\r\n *\r\n * @HindleyMilner merge :: [a] -> [b]\r\n *\r\n * @pure\r\n * @param {array|object} sources\r\n * @return {array|object}\r\n *\r\n * @example\r\n * import {merge} from '@7urtle/lambda';\r\n *\r\n * const obj1 = { a: 'a', c: ['a'] };\r\n * const obj2 = { b: a => a, d: ['a', 'b'] };\r\n * const obj3 = { a: 'c', c: ['c'] };\r\n *\r\n * merge(obj1, obj2, obj3));\r\n * // => {\"a\": \"c\", \"b\": a => a, \"c\": [\"a\", \"c\"], \"d\": [\"a\", \"b\"]}\r\n *\r\n * const list1 = ['a', 'b'];\r\n * const list2 = [1, 2];\r\n *\r\n * merge(list1,list2);\r\n * // => ['a', 'b', 1, 2]\r\n */\r\nexport const merge = (...sources) =>\r\n    reduce\r\n        ([])\r\n        ((acc, current) =>\r\n            isArray(current)\r\n                ? [...acc, ...current]\r\n                : isObject(current)\r\n                    ? reduce\r\n                        (acc)\r\n                        ((a, c) =>\r\n                            isObject(current[c]) && c in acc\r\n                                ? { ...a, [c]: merge(acc[c], current[c]) }\r\n                                : { ...a, [c]: current[c] }\r\n                        )\r\n                        (Object.getOwnPropertyNames(current))\r\n                    : { ...acc, ...current }\r\n        )\r\n        (sources);\r\n\r\n/**\r\n * includes(a)(b) output is true if b includes a.\r\n *\r\n * includes can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner includes :: a -> b -> boolean\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @param {*} b\r\n * @return {*}\r\n *\r\n * @example\r\n * import {includes} from '@7urtle/lambda';\r\n *\r\n * includes('rt')('7urtle'); // => true\r\n * includes(1)([1, 2, 3]) // => true\r\n * includes('turtle')([1, 2, 3]) // => false\r\n *\r\n * // includes can be called both as a curried unary function or as a standard binary function\r\n * includes('rt')('7urtle') === includes('rt', '7urtle');\r\n */\r\nexport const includes = nary(a => b => b.includes(a));\r\n\r\n/**\r\n * indexOf(a)(b) outputs position of input a within input b or undefined if it is not found.\r\n *\r\n * indexOf can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner indexOf :: a -> b -> number\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @param {*} b\r\n * @return {*}\r\n *\r\n * @example\r\n * import {indexOf} from '@7urtle/lambda';\r\n *\r\n * indexOf('7')('7urtle'); // => 0\r\n * indexOf(7)('7urtle'); // => 0\r\n * indexOf(2)([1, 2, 3]); // => 1\r\n * indexOf(4)([1, 2, 3]); // => undefined\r\n *\r\n * // indexOf can be called both as a curried unary function or as a standard binary function\r\n * indexOf('7')('7urtle') === indexOf('7', '7urtle');\r\n */\r\nexport const indexOf = nary(a => b => minusOneToUndefined(b.indexOf(a)));\r\n\r\n/**\r\n * lastIndexOf(a)(b) outputs position of input a withing input b looking from the end or it retuns undefined if it is not found.\r\n *\r\n * lastIndexOf can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner lastIndexOf :: a -> b -> number\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @param {*} b\r\n * @return {*}\r\n *\r\n * @example\r\n * import {lastIndexOf} from '@7urtle/lambda';\r\n *\r\n * lastIndexOf('urtle')('7urtle'); // => 1\r\n * lastIndexOf(2)([1, 2, 3, 2]); // => 3\r\n * lastIndexOf('8')('7urtle'); // => undefined\r\n *\r\n * // lastIndexOf can be called both as a curried unary function or as a standard binary function\r\n * lastIndexOf('7')('7urtle') === lastIndexOf('7', '7urtle');\r\n */\r\nexport const lastIndexOf = nary(a => b => minusOneToUndefined(b.lastIndexOf(a)));\r\n\r\n/**\r\n * memoize uses input memory to save output of input function and then uses it to lookup the result on a repeated run. This\r\n * function is not pure because the input memory is modified in the process.\r\n *\r\n * The function can be called both as a curried unary function or as a standard ternary function.\r\n *\r\n * @HindleyMilner memoize :: object -> (a -> b) -> a -> b\r\n *\r\n * @param {object} memory\r\n * @param {function} fn\r\n * @param {*} anything\r\n * @return {*}\r\n *\r\n * @example\r\n * import {memoize} from '@7urtle/lambda';\r\n *\r\n * const addTwo = a => a + 2;\r\n * let memory = {};\r\n *\r\n * memoize(memory)(addTwo)(1); // => 3\r\n * memoize(memory)(addTwo)(1); // => 3\r\n * memory[1]; // => 3\r\n *\r\n * // lastIndexOf can be called both as a curried unary function or as a standard ternary function\r\n * memoize(memory)(addTwo)(1) === memoize(memory, addTwo, 1);\r\n */\r\nexport const memoize = nary(memory => fn => anything =>\r\n    anything in memory\r\n        ? memory[anything]\r\n        : passThrough(b => memory[anything] = b)(fn(anything))\r\n);\r\n\r\n/**\r\n * memo takes input function and returns it enhanced by memoization which ensures that each result is\r\n * always remembered internally and executed only once.\r\n *\r\n * @HindleyMilner memo :: (a -> b) -> (a -> b)\r\n *\r\n * @pure\r\n * @param {function} fn\r\n * @return {function}\r\n *\r\n * @example\r\n * import {memo} from '@7urtle/lambda';\r\n *\r\n * const addTwo = a => a + 2;\r\n * const memoAddTwo = memo(addTwo);\r\n * const memoAddThree = memo(a => a + 3);\r\n *\r\n * memoAddTwo(1); // => 3\r\n * memoAddThree(1); // => 4\r\n *\r\n * let count = 0;\r\n * const increaseCount = () => ++count;\r\n *\r\n * increaseCount(); // 1\r\n * increaseCount(); // 2\r\n *\r\n * const memoIncreaseCount = memo(increaseCount);\r\n *\r\n * memoIncreaseCount(); // 3\r\n * memoIncreaseCount(); // 3\r\n * memoIncreaseCount(); // 3\r\n */\r\nexport const memo = fn => memoize({})(fn);","import {isArray, isEqual, isString, isObject, isFunction, isNull, isUndefined, isGreaterThan} from \"./conditional\";\r\nimport {keysOf, join} from \"./list\";\r\nimport {map} from \"./core\";\r\nimport {nary} from \"./arity\";\r\n\r\n/**\r\n * typeOf outputs a type of its input.\r\n *\r\n * @HindleyMilner typeOf :: a -> string\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {string}\r\n *\r\n * @example\r\n * import {typeOf} from '@7urtle/lambda';\r\n *\r\n * typeOf('7turtle'); // => 'string'\r\n */\r\nexport const typeOf = a => typeof a;\r\n\r\n/**\r\n * lengthOf outputs the length of an input.\r\n *\r\n * @HindleyMilner lengthOf :: (string|array) -> number\r\n *\r\n * @pure\r\n * @param {string|array} a\r\n * @return {number}\r\n *\r\n * @example\r\n * import {lengthOf} from '@7urtle/lambda';\r\n *\r\n * lengthOf('7turtle'); // => 7\r\n * lengthOf([1,2,3]); // => 3\r\n * lengthOf({}); // => undefined\r\n */\r\nexport const lengthOf = a => a.length;\r\n\r\n/**\r\n * passThrough output is the same as input a. passThrough executes function passed as first argument.\r\n *\r\n * passThrough can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner passThrough :: function -> a -> a\r\n *\r\n * @pure\r\n * @param {function} fn\r\n * @param {*} anything\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {passThrough} from '@7urtle/lambda';\r\n *\r\n * passThrough(() => 'b')('a'); // => 'a'\r\n *\r\n * // isTypeOf can be called both as a curried unary function or as a standard binary function\r\n * passThrough(() => 'b')('a') === passThrough(() => 'b', 'a');\r\n */\r\nexport const passThrough = nary(fn => anything => {\r\n  fn(anything);\r\n  return anything;\r\n});\r\n\r\n/**\r\n * log output is the same as input and it logs the input value. log causes side effect of console.log.\r\n *\r\n * @HindleyMilner log :: a -> a\r\n *\r\n * @param {*} anything\r\n * @return {*}\r\n *\r\n * @example\r\n * import {log} from '@7urtle/lambda';\r\n *\r\n * log('anything'); // => 'anything'\r\n */\r\nexport const log = passThrough(console.log);\r\n\r\n/**\r\n * spy output is the same as input and it logs the deepInspect of the input. spy causes side effect of console.log.\r\n *\r\n * @HindleyMilner spy :: a -> a\r\n *\r\n * @param {*} anything\r\n * @return {*}\r\n *\r\n * @example\r\n * import {spy} from '@7urtle/lambda';\r\n *\r\n * spy([1, 'a']); // => \"[1, 'a']\"\r\n */\r\nexport const spy = passThrough(a => console.log(deepInspect(a)));\r\n\r\n/**\r\n * minusOneToUndefined output is the same as input or undefined if input is -1.\r\n *\r\n * Because some functions return -1 as error state, this function is created to change it into a more consistent\r\n * undefined output.\r\n *\r\n * @HindleyMilner minusOneToUndefined :: a -> a|boolean\r\n *\r\n * @pure\r\n * @param {*} anything\r\n * @return {*|boolean}\r\n *\r\n * @example\r\n * import {log} from '@7urtle/lambda';\r\n *\r\n * minusOneToUndefined(-1); // => undefined\r\n * minusOneToUndefined(0); // => 0\r\n * minusOneToUndefined('7urtle'); // => '7urtle'\r\n */\r\nexport const minusOneToUndefined = anything => isEqual(-1)(anything) ? undefined: anything;\r\n\r\n/**\r\n * inspectFunction outputs name of named function or its conversion to string.\r\n *\r\n * @HindleyMilner inspectFunction :: (a -> b) -> string\r\n *\r\n * @pure\r\n * @param {function} fn\r\n * @return {string}\r\n *\r\n * @example\r\n * import {inspectFunction} from '@7urtle/lambda';\r\n *\r\n * function namedFunction() {\r\n *   return null;\r\n * }\r\n *\r\n * inspectFunction(namedFunction); // => 'namedFunction'\r\n * inspectFunction(() => 'b');\r\n * // => `function () {\r\n * // =>     return 'b';\r\n * // => }`\r\n */\r\nexport const inspectFunction = fn => fn.name ? fn.name : String(fn);\r\n\r\n/**\r\n * inspectArray maps over input array [a] and outputs string representing it.\r\n *\r\n * @HindleyMilner inspectArray :: [a] -> string\r\n *\r\n * @pure\r\n * @param {array} a\r\n * @return {string}\r\n *\r\n * @example\r\n * import {inspectArray} from '@7urtle/lambda';\r\n *\r\n * function namedFunction() {\r\n *   return null;\r\n * }\r\n *\r\n * inspectArray([1, 'a']); // => \"[1, 'a']\"\r\n * inspectArray([namedFunction, 'a']); // => \"[namedFunction, 'a']\"\r\n */\r\nexport const inspectArray = a => `[${join(', ')(map(deepInspect)(a))}]`;\r\n\r\n/**\r\n * inspectString outputs string representing input.\r\n *\r\n * @HindleyMilner inspectString :: a -> string\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {string}\r\n *\r\n * @example\r\n * import {inspectString} from '@7urtle/lambda';\r\n *\r\n * inspectString('my string'); // => \"'my string'\"\r\n */\r\nexport const inspectString = a => `'${a}'`;\r\n\r\n/**\r\n * inspectObject outputs string representing input.\r\n *\r\n * @HindleyMilner inspectObject :: a -> string\r\n *\r\n * @pure\r\n * @param {object} a\r\n * @return {string}\r\n *\r\n * @example\r\n * import {inspectObject} from '@7urtle/lambda';\r\n *\r\n * inspectObject({a: 'b'}); // => \"{a: 'b'}\"\r\n */\r\nexport const inspectObject = a =>\r\n  isFunction(a.inspect)\r\n    ? a.inspect()\r\n    : `{${join(', ')(map(join(': '))(map(k => [k, deepInspect(a[k])])(keysOf(a))))}}`\r\n\r\n/**\r\n * deepInspect runs recursively over input and outputs string representing the input.\r\n *\r\n * @HindleyMilner deepInspect :: a -> string\r\n *\r\n * @pure\r\n * @param {*} a\r\n * @return {string}\r\n *\r\n * @example\r\n * import {deepInspect} from '@7urtle/lambda';\r\n *\r\n * function namedFunction() {\r\n *   return null;\r\n * }\r\n *\r\n * deepInspect({a: 'b'}); // => \"{a: 'b'}\"\r\n * deepInspect(namedFunction); // => 'namedFunction'\r\n * deepInspect([1, 'a']); // => \"[1, 'a']\"\r\n * deepInspect('my string'); // => \"'my string'\"\r\n * deepInspect(undefined); // => 'undefined'\r\n */\r\nexport const deepInspect = a =>\r\n  isUndefined(a)\r\n    ? 'undefined'\r\n    : isNull(a)\r\n      ? 'null'\r\n      : isFunction(a)\r\n        ? inspectFunction(a)\r\n        : isArray(a)\r\n          ? inspectArray(a)\r\n          : isObject(a)\r\n            ? inspectObject(a)\r\n            : isString(a)\r\n              ? inspectString(a)\r\n              : String(a);","import {minusOneToUndefined} from './utils';\r\nimport {nary} from \"./arity\";\r\n\r\n/**\r\n * trim output is a string without white characters around it.\r\n *\r\n * @HindleyMilner trim :: string -> string\r\n *\r\n * @pure\r\n * @param {string} string\r\n * @return {string}\r\n *\r\n * @example\r\n * import {trim} from '@7urtle/lambda';\r\n *\r\n * trim(' a \\n '); // => 'a'\r\n */\r\nexport const trim = string => string.trim();\r\n\r\n/**\r\n * testRegEx outputs true if string b passes regular expression a.\r\n *\r\n * testRegEx can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner testRegEx :: regex -> string -> boolean\r\n *\r\n * @pure\r\n * @param {regex} regex\r\n * @param {string} string\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {testRegEx} from '@7urtle/lambda';\r\n *\r\n * testRegEx(/[a-z]/)('7urtle'); // => true\r\n * testRegEx(/[0-9]/)('1'); // => true\r\n * testRegEx(/[0-9]/)('abc'); // => false\r\n *\r\n * // testRegEx can be called both as a curried unary function or as a standard binary function\r\n * testRegEx(/[a-z]/)('7urtle') === testRegEx(/[a-z]/, '7urtle');\r\n */\r\nexport const testRegEx = nary(regex => string => regex.test(string));\r\n\r\n/**\r\n * substr outputs substring based on provided string, start and limit.\r\n *\r\n * substr can be called both as a curried unary function or as a standard ternary function.\r\n *\r\n * @HindleyMilner substr :: number -> number -> string -> string\r\n *\r\n * @pure\r\n * @param {number} limit\r\n * @param {number} start\r\n * @param {string} string\r\n * @return {string}\r\n *\r\n * @example\r\n * import {substr} from '@7urtle/lambda';\r\n *\r\n * substr(3)(1)('7urtle'); // => 'urt'\r\n * substr(1)(0)('7urtle'); // => '7'\r\n * substr(1)(-1)('7urtle'); // => 'e'\r\n *\r\n * // substr can be called both as a curried unary function or as a standard ternary function\r\n * substr(3)(1)('7urtle') === substr(3, 1, '7urtle');\r\n */\r\nexport const substr = nary(limit => start => string => string.substr(start, limit));\r\n\r\n/**\r\n * firstLetterOf outputs the first letter of a provided string.\r\n *\r\n * @HindleyMilner firstLetterOf :: string -> string\r\n *\r\n * @pure\r\n * @param {string} string\r\n * @return {string}\r\n *\r\n * @example\r\n * import {firstLetterOf} from '@7urtle/lambda';\r\n *\r\n * firstLetterOf('7urtle'); // => '7'\r\n */\r\nexport const firstLetterOf = string => string.substr(0, 1);\r\n\r\n/**\r\n * lastLetterOf outputs the last letter of a provided string.\r\n *\r\n * @HindleyMilner lastLetterOf :: string -> string\r\n *\r\n * @pure\r\n * @param {string} string\r\n * @return {string}\r\n *\r\n * @example\r\n * import {lastLetterOf} from '@7urtle/lambda';\r\n *\r\n * lastLetterOf('7urtle'); // => 'e'\r\n */\r\nexport const lastLetterOf = string => string.substr(-1, 1);\r\n\r\n/**\r\n * startsWith outputs true if an input string starts with provided string.\r\n *\r\n * startsWith can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner startsWith :: string -> string -> boolean\r\n *\r\n * @pure\r\n * @param {string} substring\r\n * @param {string} string\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {startsWith} from '@7urtle/lambda';\r\n *\r\n * startsWith('7')('7urtle'); // => true\r\n * startsWith('7urtl')('7urtle'); // => true\r\n * startsWith('8urtl')('7urtle'); // => false\r\n *\r\n * // startsWith can be called both as a curried unary function or as a standard binary function\r\n * startsWith('7')('7urtle') === startsWith('7', '7urtle');\r\n */\r\nexport const startsWith = nary(substring => string => string.startsWith(substring));\r\n\r\n/**\r\n * endsWith outputs true if an input string ends with provided string.\r\n *\r\n * endsWith can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner endsWith :: string -> string -> boolean\r\n *\r\n * @pure\r\n * @param {string} substring\r\n * @param {string} string\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {endsWith} from '@7urtle/lambda';\r\n *\r\n * endsWith('7e')('7urtle'); // => true\r\n * endsWith('urtle')('7urtle'); // => true\r\n * endsWith('urtls')('7urtle'); // => false\r\n *\r\n * // endsWith can be called both as a curried unary function or as a standard binary function\r\n * endsWith('e')('7urtle') === endsWith('e', '7urtle');\r\n */\r\nexport const endsWith = nary(substring => string => string.endsWith(substring));\r\n\r\n/**\r\n * repeat outputs new string repeating input string inputted count of times.\r\n *\r\n * repeat can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner repeat :: number -> string -> string\r\n *\r\n * @pure\r\n * @param {number} count\r\n * @param {string} string\r\n * @return {string}\r\n *\r\n * @example\r\n * import {repeat} from '@7urtle/lambda';\r\n *\r\n * repeat(2)('7urtle'); // => '7urtle7urtle'\r\n * repeat(0)('7urtle'); // => ''\r\n *\r\n * // repeat can be called both as a curried unary function or as a standard binary function\r\n * repeat(2)('7urtle') === repeat(2, '7urtle');\r\n */\r\nexport const repeat = nary(count => string => string.repeat(count));\r\n\r\n/**\r\n * replace outputs new string replacing input substring with input replacement string in input string.\r\n *\r\n * replace can be called both as a curried unary function or as a standard ternary function.\r\n *\r\n * @HindleyMilner replace :: string -> string -> string -> string\r\n *\r\n * @pure\r\n * @param {string} replacement\r\n * @param {string} substring\r\n * @param {string} string\r\n * @return {string}\r\n *\r\n * @example\r\n * import {replace} from '@7urtle/lambda';\r\n *\r\n * replace('8')('7')('7urtle'); // => '8urtle'\r\n * replace('7')('')('7urtle'); // => '77urtle'\r\n * replace('')('7')('7urtle'); // => 'urtle'\r\n *\r\n * // replace can be called both as a curried unary function or as a standard ternary function\r\n * replace('8')('7')('7urtle') === replace('8', '7', '7urtle');\r\n */\r\nexport const replace = nary(replacement => substring => string => string.replace(substring, replacement));\r\n\r\n/**\r\n * search outputs position of input substring or regular expression withing input string or undefined if it is not found.\r\n *\r\n * search can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner search :: string/regex -> string -> number\r\n *\r\n * @pure\r\n * @param {string|regex} substring\r\n * @param {string} string\r\n * @return {number}\r\n *\r\n * @example\r\n * import {search} from '@7urtle/lambda';\r\n *\r\n * search('7')('7urtle'); 0\r\n * search('e')('7urtle'); // => 5\r\n * search('rt')('7urtle'); // => 2\r\n * search(/URT/i)('7urtle'); // => 1\r\n * search('8')('7urtle'); => undefined\r\n *\r\n * // search can be called both as a curried unary function or as a standard binary function\r\n * search('7')('7urtle') === search('7', '7urtle');\r\n */\r\nexport const search = nary(substring => string => minusOneToUndefined(string.search(substring)));\r\n\r\n/**\r\n * split outputs and array of an input string split by the input substring.\r\n *\r\n * split can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner split :: string -> string -> array\r\n *\r\n * @pure\r\n * @param {string} substring\r\n * @param {string} string\r\n * @return {array}\r\n *\r\n * @example\r\n * import {split} from '@7urtle/lambda';\r\n *\r\n * split(' ')('7urtles are awesome'); // => ['7urtles', 'are', 'awesome']\r\n * split('/')('7urtles are awesome'); // => ['7urtles are awesome']\r\n *\r\n * // split can be called both as a curried unary function or as a standard binary function\r\n * split(' ')('7urtles are awesome') === split(' ', '7urtles are awesome');\r\n */\r\nexport const split = nary(substring => string => string.split(substring));\r\n\r\n/**\r\n * lowerCaseOf outputs the lower case version of input string.\r\n *\r\n * @HindleyMilner lowerCaseOf :: string -> string\r\n *\r\n * @pure\r\n * @param {string} string\r\n * @return {string}\r\n *\r\n * @example\r\n * import {lowerCaseOf} from '@7urtle/lambda';\r\n *\r\n * lowerCaseOf('PeTrA'); // => 'petra'\r\n * lowerCaseOf('PŘÍŠERNĚ ŽLUŤOUČKÝ KŮŇ ÚPĚL ĎÁBELSKÉ ÓDY'); // => 'příšerně žluťoučký kůň úpěl ďábelské ódy'\r\n */\r\nexport const lowerCaseOf = string => string.toLowerCase();\r\n\r\n/**\r\n * upperCaseOf outputs the upper case version of input string.\r\n *\r\n * @HindleyMilner upperCaseOf :: string -> string\r\n *\r\n * @pure\r\n * @param {string} string\r\n * @return {string}\r\n *\r\n * @example\r\n * import {upperCaseOf} from '@7urtle/lambda';\r\n *\r\n * upperCaseOf('PeTrA'); // => 'PETRA'\r\n * upperCaseOf('příšerně žluťoučký kůň úpěl ďábelské ódy'); // => 'PŘÍŠERNĚ ŽLUŤOUČKÝ KŮŇ ÚPĚL ĎÁBELSKÉ ÓDY'\r\n */\r\nexport const upperCaseOf = string => string.toUpperCase();","import {lengthOf, minusOneToUndefined} from './utils';\r\nimport {nary} from \"./arity\";\r\nimport {upperCaseOf} from \"./string\";\r\nimport {concat, merge} from \"./core\";\r\n\r\n/**\r\n * reduce executes input reducer function that over each member of input array [b] to output a single value. It is\r\n * the preferred way of working functionally with arrays as it is a pure function that does not cause mutations.\r\n *\r\n * reduce executes functions in reverse order to reduceRight.\r\n *\r\n * reduce can be called both as a curried unary function or as a standard ternary function.\r\n *\r\n * @HindleyMilner reduce :: a -> ((a, b) -> a) -> [b] -> a\r\n *\r\n * @pure\r\n * @param {*} initial\r\n * @param {function} reducer\r\n * @param {array} list\r\n * @return {*}\r\n *\r\n * @example\r\n * import {reduce} from '@7urtle/lambda';\r\n *\r\n * const reducer = (accumulator, currentValue) => accumulator + currentValue;\r\n * const list = ['a', 'b', 'c'];\r\n *\r\n * reduce('start')(reducer)(list); // => startabc\r\n *\r\n * // reduce can be called both as a curried unary function or as a standard ternary function\r\n * reduce('start')(reducer)(list) === reduce('start', reducer, list);\r\n */\r\nexport const reduce = nary(initial => reducer => list => list.reduce(reducer, initial));\r\n\r\n/**\r\n * reduceRight executes input reducer function that over each member of input array [b] to output a single value. It is\r\n * the preferred way of working functionally with arrays as it is a pure function that does not cause mutations.\r\n *\r\n * reduceRight executes functions in reverse order to reduce.\r\n *\r\n * reduceRight can be called both as a curried unary function or as a standard ternary function.\r\n *\r\n * @HindleyMilner reduceRight :: a -> ((a, b) -> a) -> [b] -> a\r\n *\r\n * @pure\r\n * @param {*} initial\r\n * @param {function} reducer\r\n * @param {array} list\r\n * @return {*}\r\n *\r\n * @example\r\n * import {reduceRight} from '@7urtle/lambda';\r\n *\r\n * const reducer = (accumulator, currentValue) => accumulator + currentValue;\r\n * const list = ['a', 'b', 'c'];\r\n *\r\n * reduceRight('start')(reducer)(list); // => startcba\r\n *\r\n * // reduceRight can be called both as a curried unary function or as a standard ternary function\r\n * reduceRight('start')(reducer)(list) === reduceRight('start', reducer, list);\r\n */\r\nexport const reduceRight = nary(initial => reducer => list => list.reduceRight(reducer, initial));\r\n\r\n/**\r\n * filter executes input checker over each member of input array [a] to filter and output filtered new array [b].\r\n *\r\n * If you need to both filter and map over an array, consider using the filterMap function.\r\n *\r\n * filter can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner filter :: (a -> boolean) -> [a] -> [b]\r\n *\r\n * @pure\r\n * @param {function} checker\r\n * @param {array} list\r\n * @return {*}\r\n *\r\n * @example\r\n * import {filter} from '@7urtle/lambda';\r\n *\r\n * const list = [0, 1, 2, 3]\r\n *\r\n * filter(a => a > 1)(list); // => [2, 3]\r\n *\r\n * // filter can be called both as a curried unary function or as a standard binary function\r\n * filter(a => a > 1)(list) === filter(a => a > 1, list);\r\n */\r\nexport const filter = nary(checker => list => list.filter(checker));\r\n\r\n/**\r\n * filterMap executes mapper function over filtered input array or monad and outputs the resulting array or monad.\r\n *\r\n * Only one pass through the array is executed unlike the use of map(mapper)(filter(checker)(list)).\r\n *\r\n * filterMap can be called both as a curried unary function or as a standard ternary function.\r\n *\r\n * @HindleyMilner filterMap :: (a -> boolean) -> (a -> b) -> [a] -> [b]\r\n *\r\n * @pure\r\n * @param {function} checker\r\n * @param {function} mapper\r\n * @param {array} list\r\n * @return {*}\r\n *\r\n * @example\r\n * import {filterMap} from '@7urtle/lambda';\r\n *\r\n * const list = [0, 1, 2, 3]\r\n * const mapper = a => a + 1;\r\n * const checker = a => a > 1;\r\n *\r\n * filterMap(checker)(mapper)(list);  // => [3, 4]\r\n * filterMap(a => a > 1)(a => a + 1)([0, 1, 2, 3]); // => [3, 4]\r\n *\r\n * const mapOverLargerThanOne = filterMap(checker);\r\n * mapOverLargerThanOne(mapper)(list); // => [3, 4]\r\n *\r\n * // filterMap can be called both as a curried unary function or as a standard ternary function\r\n * filterMap(a => a > 1)(a => a + 1)(list) === filterMap(a => a > 1, a => a + 1, list);\r\n */\r\nexport const filterMap = nary(checker => mapper => list =>\r\n    reduce([])((acc, current) => checker(current) ? acc.push(mapper(current)) && acc : acc)(list));\r\n\r\n/**\r\n * find executes input checker over each member of input array [a] and outputs the first array member that matches checker or undefined.\r\n *\r\n * find can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner find :: (a -> boolean) -> [a] -> [b]\r\n *\r\n * @pure\r\n * @param {function} checker\r\n * @param {array} list\r\n * @return {*}\r\n *\r\n * @example\r\n * import {find} from '@7urtle/lambda';\r\n *\r\n * const list = [0, 1, 2, 3]\r\n *\r\n * find(a => a > 1)(list); // => 2\r\n * find(a => a > 3)(list); // => undefined\r\n *\r\n * // find can be called both as a curried unary function or as a standard binary function\r\n * find(a => a > 1)(list) === find(a => a > 1, list);\r\n */\r\nexport const find = nary(checker => list => list.find(checker));\r\n\r\n/**\r\n * findIndex executes input checker over each member of input array [a] and outputs the index of first array member that matches checker or undefined.\r\n *\r\n * findIndex can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner findIndex :: (a -> boolean) -> [a] -> [b]\r\n *\r\n * @pure\r\n * @param {function} checker\r\n * @param {array} list\r\n * @return {*}\r\n *\r\n * @example\r\n * import {findIndex} from '@7urtle/lambda';\r\n *\r\n * const list = [2, 3, 4];\r\n *\r\n * findIndex(a => a > 2)(list); // => 1\r\n * findIndex(a => a > 4)(list); // => undefined\r\n *\r\n * // findIndex can be called both as a curried unary function or as a standard binary function\r\n * findIndex(a => a > 1)(list) === findIndex(a => a > 1, list);\r\n */\r\nexport const findIndex = nary(checker => list => minusOneToUndefined(list.findIndex(checker)));\r\n\r\n/**\r\n * join outputs a string created by joining input array members with input separator.\r\n *\r\n * join can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner join :: string -> [a] -> string\r\n *\r\n * @pure\r\n * @param {string} separator\r\n * @param {array} list\r\n * @return {*}\r\n *\r\n * @example\r\n * import {join} from '@7urtle/lambda';\r\n *\r\n * const list = [2, 3, 4];\r\n *\r\n * join('')(list); // => '234'\r\n * join(' and ')(list); // => '2 and 3 and 4'\r\n * join()(list); // => '2,3,4'\r\n *\r\n * // join can be called both as a curried unary function or as a standard binary function\r\n * join('')(list) === join('', list);\r\n */\r\nexport const join = nary(separator => list => list.join(separator));\r\n\r\n/**\r\n * keysOf outputs array of string keys of input array or object.\r\n *\r\n * @HindleyMilner keysOf :: object -> [string]\r\n *\r\n * @pure\r\n * @param {Object|array} list\r\n * @return {array}\r\n *\r\n * @example\r\n * import {keysOf} from '@7urtle/lambda';\r\n *\r\n * keysOf([2, 3, 4]); // => ['0', '1', '2']\r\n * keysOf({1: 2, 2: 3}); // => ['1', '2']\r\n */\r\nexport const keysOf = Object.keys;\r\n\r\n/**\r\n * entriesOf outputs array of arrays of string keys and raw values of input array or object.\r\n *\r\n * @HindleyMilner entriesOf :: object -> [[string, a]]\r\n *\r\n * @pure\r\n * @param {Object|array} list\r\n * @return {array}\r\n *\r\n * @example\r\n * import {entriesOf} from '@7urtle/lambda';\r\n *\r\n * entriesOf([2, 3, 4]); // => [['0', 2], ['1', 3], ['2', 4]]\r\n * entriesOf({1: 2, 2: 3}); // => [['1', 2],['2', 3]]\r\n */\r\nexport const entriesOf = Object.entries;\r\n\r\n/**\r\n * everyOf outputs true if every element of input array passes input checker function as true.\r\n *\r\n * everyOf can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner everyOf :: (a -> boolean) -> [a] -> boolean\r\n *\r\n * @pure\r\n * @param {function} checker\r\n * @param {array} list\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {everyOf} from '@7urtle/lambda';\r\n *\r\n * everyOf(a => a > 1)([2, 3, 4]); // => true\r\n * everyOf(a => a > 5)([2, 3, 4]); // => false\r\n *\r\n * // everyOf can be called both as a curried unary function or as a standard binary function\r\n * everyOf(a => a > 1)([2, 3, 4]) === everyOf(a => a > 1, [2, 3, 4]);\r\n */\r\nexport const everyOf = nary(checker => list => list.every(checker));\r\n\r\n/**\r\n * slice outputs selected array elements as an array based on input range. First argument end\r\n * represents the ending index (not length) and start represents the starting index in the input\r\n * array list.\r\n *\r\n * slice can be called both as a curried unary function or as a standard ternary function.\r\n *\r\n * @HindleyMilner slice :: number -> number -> [a] -> [a]\r\n *\r\n * @pure\r\n * @param {number} end\r\n * @param {number} start\r\n * @param {array} list\r\n * @return {array}\r\n *\r\n * @example\r\n * import {slice} from '@7urtle/lambda';\r\n *\r\n * slice(2)(1)([1, 2, 3, 4, 5]); // => [2]\r\n * slice(2)(0)([1, 2, 3, 4, 5]); // => [1, 2]\r\n * slice(8)(7)([1, 2, 3, 4, 5]); // => []\r\n *\r\n * // slice can be called both as a curried unary function or as a standard ternary function\r\n * slice(2)(1)([1, 2, 3, 4, 5]) === slice(2, 1, [1, 2, 3, 4, 5]);\r\n */\r\nexport const slice = nary(end => start => list => list.slice(start, end));\r\n\r\n/**\r\n * some outputs true if any element of input array passes input checker function as true.\r\n *\r\n * some can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner some :: (a -> boolean) -> [a] -> boolean\r\n *\r\n * @pure\r\n * @param {function} checker\r\n * @param {array} list\r\n * @return {boolean}\r\n *\r\n * @example\r\n * import {some} from '@7urtle/lambda';\r\n *\r\n * someOf(a => a > 1)([2, 3, 4]); // => true\r\n * someOf(a => a > 5)([2, 3, 4]); // => false\r\n *\r\n * // some can be called both as a curried unary function or as a standard binary function\r\n * someOf(a => a > 1)([2, 3, 4]) === someOf(a => a > 1, [2, 3, 4]);\r\n */\r\nexport const someOf = nary(checker => list => list.some(checker));\r\n\r\n/**\r\n * sort outputs an array sorted based on input compare function.\r\n *\r\n * sort can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner sort :: (a -> number) -> [a] -> [a]\r\n *\r\n * @pure\r\n * @param {function} compare\r\n * @param {array} list\r\n * @return {array}\r\n *\r\n * @example\r\n * import {sort} from '@7urtle/lambda';\r\n *\r\n * sort((a, b) => a < b ? -1 : a > b ? 1 : 0)(['a', 'd', 'c', 'd']); // => ['a', 'c', 'd', 'd']\r\n * sort((a, b) => a - b)([5, 3, 6]); // => [3, 5, 6]\r\n *\r\n * // sort can be called both as a curried unary function or as a standard binary function\r\n * sort((a, b) => a - b)([5, 3, 6]) === sort((a, b) => a - b, [5, 3, 6]);\r\n */\r\nexport const sort = nary(compare => list => [...list].sort(compare));\r\n\r\n/**\r\n * sortAlphabetically outputs an array sorted alphabetically from a to z.\r\n *\r\n * @HindleyMilner sortAlphabetically :: [string] -> [string]\r\n *\r\n * @pure\r\n * @param {array} list\r\n * @return {array}\r\n *\r\n * @example\r\n * import {sortAlphabetically} from '@7urtle/lambda';\r\n *\r\n * sortAlphabetically(['petra', 'Martin', 'Petra']); // => ['Martin', 'petra', 'Petra']\r\n */\r\nexport const sortAlphabetically = sort((a, b) => (a => b => a < b ? -1 : a > b ? 1 : 0)(upperCaseOf(a))(upperCaseOf(b)));\r\n\r\n/**\r\n * sortAlphabeticallyZA outputs an array sorted alphabetically from z to a.\r\n *\r\n * @HindleyMilner sortAlphabeticallyZA :: [string] -> [string]\r\n *\r\n * @pure\r\n * @param {array} list\r\n * @return {array}\r\n *\r\n * @example\r\n * import {sortAlphabeticallyZA} from '@7urtle/lambda';\r\n *\r\n * sortAlphabeticallyZA(['petra', 'Martin', 'Petra']); // => ['petra', 'Petra', 'Martin']\r\n */\r\nexport const sortAlphabeticallyZA = sort((a, b) => (a => b => a < b ? 1 : a > b ? -1 : 0)(upperCaseOf(a))(upperCaseOf(b)));\r\n\r\n/**\r\n * sortNumerically outputs an array sorted numerically from 1 to 2.\r\n *\r\n * @HindleyMilner sortNumerically :: [number] -> [number]\r\n *\r\n * @pure\r\n * @param {array} list\r\n * @return {array}\r\n *\r\n * @example\r\n * import {sortNumerically} from '@7urtle/lambda';\r\n *\r\n * sortNumerically([3, 4, 1, 3]); // => [1, 3, 3, 4]\r\n */\r\nexport const sortNumerically = sort((a, b) => a - b);\r\n\r\n/**\r\n * sortNumerically21 outputs an array sorted numerically from 2 to 1.\r\n *\r\n * @HindleyMilner sortNumerically21 :: [number] -> [number]\r\n *\r\n * @pure\r\n * @param {array} list\r\n * @return {array}\r\n *\r\n * @example\r\n * import {sortNumerically21} from '@7urtle/lambda';\r\n *\r\n * sortNumerically21([3, 4, 1, 3]); // => [4, 3, 3, 1]\r\n */\r\nexport const sortNumerically21 = sort((a, b) => b - a);\r\n\r\n/**\r\n * headOf outputs the first item (head) from the input array.\r\n *\r\n * @HindleyMilner headOf :: [a] -> a\r\n *\r\n * @pure\r\n * @param {array} list\r\n * @return {any}\r\n *\r\n * @example\r\n * import {headOf} from '@7urtle/lambda';\r\n *\r\n * headOf([3, 4, 1, 8]); // => 3\r\n * headOf([8]); // => 8\r\n */\r\nexport const headOf = list => list[0];\r\n\r\n/**\r\n * tailOf outputs the the input array without its first item.\r\n *\r\n * @HindleyMilner tailOf :: [a] -> []\r\n *\r\n * @pure\r\n * @param {array} list\r\n * @return {array}\r\n *\r\n * @example\r\n * import {tailOf} from '@7urtle/lambda';\r\n *\r\n * tailOf([3, 4, 1, 8]); // => [4, 1, 8]\r\n * tailOf([8]); // => []\r\n */\r\nexport const tailOf = list => list.slice(1);\r\n\r\n/**\r\n * initOf outputs the the input array without its last item.\r\n *\r\n * @HindleyMilner initOf :: [a] -> []\r\n *\r\n * @pure\r\n * @param {array} list\r\n * @return {array}\r\n *\r\n * @example\r\n * import {initOf} from '@7urtle/lambda';\r\n *\r\n * initOf([3, 4, 1, 8]); // => [3, 4, 1]\r\n * initOf([8]); // => []\r\n */\r\nexport const initOf = list => slice(lengthOf(list) -1)(0)(list);\r\n\r\n/**\r\n * lastOf outputs the last item from the input array.\r\n *\r\n * @HindleyMilner lastOf :: [a] -> a\r\n *\r\n * @pure\r\n * @param {array} list\r\n * @return {any}\r\n *\r\n * @example\r\n * import {lastOf} from '@7urtle/lambda';\r\n *\r\n * lastOf([3, 4, 1, 8]); // => 8\r\n * lastOf([3]); // => 3\r\n */\r\nexport const lastOf = list => list[lengthOf(list) -1];\r\n\r\n/**\r\n * groupBy outputs an objects with groups produced by an input function over input list.\r\n *\r\n * groupBy can be called both as a curried unary function or as a standard binary function.\r\n *\r\n * @HindleyMilner groupBy :: (a -> b) -> [a] -> {b: a}\r\n *\r\n * @pure\r\n * @param {function} fn\r\n * @param {array} list\r\n * @return {object}\r\n *\r\n * @example\r\n * import {groupBy} from '@7urtle/lambda';\r\n *\r\n * groupBy(a => a.length)(['one', 'two', 'three']);\r\n * // => {\"3\": [\"one\", \"two\"], \"5\": [\"three\"]}\r\n *\r\n * groupBy(a => a % 2)([1, 2, 3]);\r\n * // =>  {\"0\": [2], \"1\": [1, 3]}\r\n *\r\n * // groupBy can be called both as a curried unary function or as a standard binary function\r\n * groupBy(a => a.length)(['one', 'two', 'three']) === groupBy(a => a.length, ['one', 'two', 'three'])\r\n */\r\nexport const groupBy = nary(fn => list =>\r\n    reduce\r\n    ({})\r\n    ((acc, current) =>\r\n        (acc[fn(current)] = acc[fn(current)] || []).push(current) && acc\r\n    )\r\n    (list));","import {deepInspect} from \"./utils\";\r\nimport {isUndefined} from \"./conditional\";\r\n\r\n/**\r\n * Case is a monad that helps you with conditional processing.\r\n *\r\n * Case expects an array of key-value pairs as its input. Case.match then matches against a key to provide its value.\r\n *\r\n * Case is internally build on a JavaScript map and turns it into an applicative functor monad.\r\n *\r\n * @example\r\n * import {Case, upperCaseOf, liftA2} from '@7urtle/lambda';\r\n *\r\n * // in the example we define Case using key-value pairs. Case.of() outputs an instance of Case.\r\n * const myCase = Case.of([[1, 'one'], ['key', 'value'], ['_', 'fallback']]);\r\n *\r\n * // you reach a value by matching keys using Case.match\r\n * myCase.match(1); // => 'one'\r\n * myCase.match('key'); // => 'value'\r\n * myCase.match('nope'); // => 'fallback'\r\n *\r\n * // if no fallback is defined and no key is matched, we return undefined\r\n * Case.of([]).match('nope'); // => undefined\r\n *\r\n * // you can also inspect it by\r\n * myCase.inspect(); // => 'Case(...\r\n *\r\n * // as a functor the result is safely mappable (map doesn't execute over undefined matches)\r\n * myCase.map(value => upperCaseOf(value)).match('key'); // => 'VALUE'\r\n * Case.of([]).map(upperCaseOf).match('key'); // => undefined\r\n *\r\n * // as a monad Case can be safely flat mapped with other Cases (flatMap doesn't execute over undefined)\r\n * Case.of([[1, 'I am']]).flatMap(a => Case.of([[1, a + ' a turtle']]).match(1); // => 'I am a turtle'\r\n * Case.of([[1, 'I am']]).flatMap(a => Case.of([])).match(1); // => undefined\r\n *\r\n * // as an applicative functor you can apply Cases to each other especially using liftA2 or liftA3\r\n * const add = a => b => a + b;\r\n * liftA2(add)(Case.of([[1, 1]]))(Case.of([[1, 2]])).match(1); // => 3\r\n * Case.of([[1, add]]).ap(Case.of([[1, 'I am']])).ap(Case.of([[1, ' a turtle']])).match(1); // => 'I am a turtle'\r\n * Case.of([[1, add]]).ap(Case.of([])).ap(Case.of([[1, 'I am']])).match(1); // => undefined\r\n */\r\nexport const Case = {\r\n  of: match => getCase((match => a => match.get(a) || match.get('_') || undefined)(new Map(match)))\r\n};\r\n\r\nconst getCase = match => ({\r\n  match: match,\r\n  inspect: () => `Case(${deepInspect(match)})`,\r\n  map: fn => getCase(a => (result => isUndefined(result) ? result : fn(result))(match(a))),\r\n  flatMap: fn => getCase(a => (result => isUndefined(result) ? undefined : result.match(a))(getCase(match).map(fn).match(a))),\r\n  ap: f => getCase(match).flatMap(fn => f.map(fn))\r\n});","import {deepInspect} from \"./utils\";\r\nimport {isNothing} from \"./conditional\";\r\nimport {nary} from \"./arity\";\r\n\r\n/**\r\n * Maybe is one of the simplest and well known monads. In other languages or libraries it is also sometimes\r\n * called Option. Maybe is also quite similar to our monad Either.\r\n *\r\n * Maybe expects a value as its input. It is Nothing if the value is null, undefined, or empty. It returns\r\n * Just for all other cases.\r\n *\r\n * Maybe is called Maybe because it maybe holds a value. You want to use Maybe for situations when you don't\r\n * know whether there is going to be an output. It makes the situation very obvious and forces its consumers\r\n * to safely deal with it.\r\n *\r\n * In other languages, Maybe monad can also be called Option monad or Nullable monad.\r\n *\r\n * @example\r\n * import {maybe, Maybe, upperCaseOf, liftA2} from '@7urtle/lambda';\r\n *\r\n * // in the example we randomly give Maybe a value or undefined. Maybe.of() outputs an instance of Maybe.\r\n * const myMaybe = Maybe.of(Math.random() > 0.5 ? 'random success' : undefined);\r\n *\r\n * // you could access the actual value like this\r\n * myMaybe.value; // => 'random success' or undefined\r\n *\r\n * // you can also inspect it by\r\n * myMaybe.inspect(); // => \"Just('random success')\" or \"Nothing\"\r\n *\r\n * // you can check if the value is Nothing\r\n * myMaybe.isNothing(); // => true or false\r\n * Maybe.of('abc').isNothing(); // => false\r\n * Maybe.of([]).isNothing(); // => true\r\n *\r\n * // you can check if the value is Just\r\n * myMaybe.isJust(); // => true or false\r\n * Maybe.of(123).isJust(); // => true\r\n * Maybe.of(null).isJust(); // => false\r\n *\r\n * // as a functor the value inside is safely mappable (map doesn't execute over Nothing)\r\n * myMaybe.map(value => upperCaseOf(value));\r\n * myMaybe.inspect(); // => \"Just('RANDOM SUCCESS')\" or \"Nothing\"\r\n *\r\n * // as a monad Maybe can be safely flat mapped with other Maybes (flatMap doesn't execute over Nothing)\r\n * Maybe.of(3).flatMap(a => Maybe.of(a + 2)).inspect(); // => 'Just(5)'\r\n * Maybe.of(3).flatMap(a => Maybe.of(null)).inspect(); // => 'Nothing'\r\n * Maybe.of(3).flatMap(a => a + 2); // => 5\r\n *\r\n * // as an applicative functor you can apply Maybes to each other especially using liftA2 or liftA3\r\n * const add = a => b => a + b;\r\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)); // => Just(5)\r\n * Maybe.of(1).map(add).ap(Maybe.of(2)).inspect(); // => 'Just(3)'\r\n * Maybe.of(1).map(add).ap(Maybe.of(null)).inspect(); // => 'Nothing'\r\n * Maybe.of(add).ap(Maybe.of(1)).ap(Maybe.of(2)).inspect(); // => 'Just(3)'\r\n *\r\n * // as an example you can use Maybe to help you work with DOM like this\r\n * Maybe.of(document.querySelector('#iexist')).map(a => a.offsetTop); // => Just(1240)\r\n * Maybe.of(document.querySelector('#idontexist')).map(a => a.offsetTop); // => Nothing\r\n * maybe('error: the object doesnt exist')(a => 'offset from top is ' + a)(Maybe.of(document.querySelector('#iexist')).map(a => a.offsetTop))\r\n */\r\nexport const Maybe = {\r\n  of: value => isNothing(value) ? Nothing(value) : Just(value)\r\n};\r\n\r\nconst Nothing = value => ({\r\n  value: value,\r\n  inspect: () => 'Nothing',\r\n  isNothing: () => true,\r\n  isJust: () => false,\r\n  map: () => Nothing(value),\r\n  flatMap: () => Nothing(value),\r\n  ap: () => Nothing(value)\r\n});\r\n\r\nconst Just = value => ({\r\n  value: value,\r\n  inspect: () => `Just(${deepInspect(value)})`,\r\n  isNothing: () => false,\r\n  isJust: () => true,\r\n  map: fn => Maybe.of(fn(value)),\r\n  flatMap: fn => fn(value),\r\n  ap: f => f.map(value)\r\n});\r\n\r\n/**\r\n * maybe outputs result of a function onJust if input Maybe is Just or outputs input error if input Maybe is Nothing.\r\n *\r\n * maybe can be called both as a curried unary function or as a standard ternary function.\r\n *\r\n * @HindleyMilner maybe :: a -> (b -> c) -> Maybe -> d\r\n *\r\n * @pure\r\n * @param {*} error\r\n * @param {function} onJust\r\n * @param {Maybe} functorMaybe\r\n * @return {*}\r\n *\r\n * @example\r\n * import {maybe, Maybe} from '@7urtle/lambda';\r\n *\r\n * maybe('error')(a => a)(Maybe.of('abc')); // => 'abc'\r\n * maybe('error')(a => a)(Maybe.of(undefined)); // => 'error'\r\n * maybe('error')(a => a)(Maybe.of(undefined)) === Maybe.of(undefined).isNothing() ? 'error' ? 'not error';\r\n *\r\n * // maybe can be called both as a curried unary function or as a standard ternary function\r\n * maybe('error')(a => a)(Maybe.of('abc')) === maybe('error', a => a, Maybe.of('abc'));\r\n */\r\nexport const maybe = nary(error => onJust => functorMaybe =>\r\n  functorMaybe.isNothing()\r\n    ? error\r\n    : onJust(functorMaybe.value));","import {deepInspect} from \"./utils\";\r\nimport {nary} from \"./arity\";\r\n\r\n/**\r\n * Either is an excellent monad for handling error states and it is fairly similar to our monad Maybe. Either.Failure\r\n * represents an error state and Either.Success represents a success state.\r\n *\r\n * Either.of expects a value as its input. Either.of is the same as Either.Success. You can initiate Either\r\n * in its error state by Either.Failure.\r\n *\r\n * You can also initiate it using Either.try which expects a function as an input. It is Failure if an error\r\n * or exception is thrown. It is Success if there are no errors or exceptions.\r\n *\r\n * Either is called Either because it allows you to branch based on an error state. You want to use Either\r\n * for situations when you don't know whether there might be an error. It makes the very visible that an error\r\n * can occur and it forces the consumer to handle the situation.\r\n *\r\n * @example\r\n * import {either, Either, upperCaseOf, liftA2} from '@7urtle/lambda';\r\n *\r\n * // in the example we randomly give Either a value or throw an error. Either.try() outputs an instance of Either.\r\n * const myEither = Either.try(() => Math.random() > 0.5 ? 'random success' : throw 'random failure');\r\n *\r\n * // you can also return Either.Failure or Either.Success based on a function logic\r\n * const myFunction = Math.random() > 0.5 ? Either.Success('random success') : Either.Failure('random failure');\r\n *\r\n * // you could access the actual value like this\r\n * myEither.value; // => 'random success' or 'random failure'\r\n *\r\n * // you can also inspect it by\r\n * myEither.inspect(); // => \"Success('random success')\" or Failure('random failure')\r\n *\r\n * // Either.of and Either.Success both represent success states\r\n * Either.of('some value').inspect() === Either.Success('some value').inspect(); // => true\r\n *\r\n * // you can check if the value is Failure\r\n * myEither.isFailure(); // => true or false\r\n * Either.of('abc').isFailure(); // => false\r\n * Either.Success('anything').isFailure(); // => false\r\n * Either.Failure('anything').isFailure(); // => true\r\n * Either.try(() => {throw 'error'}).isFailure(); // => true\r\n *\r\n * // you can check if the value is Success\r\n * myEither.isSuccess(); // => true or false\r\n * Either.of('abc').isSuccess(); // => true\r\n * Either.Success('anything').isSuccess(); // => true\r\n * Either.Failure('anything').isSuccess(); // => false\r\n * Either.try(() => {throw 'error'}).isSuccess(); // => false\r\n *\r\n * // as a functor the value inside is safely mappable (map doesn't execute over Failure)\r\n * myEither.map(value => upperCaseOf(value));\r\n * myEither.inspect(); // => \"Success('RANDOM SUCCESS')\" or \"Failure('random failure')\"\r\n *\r\n * // as a monad Either can be safely flat mapped with other Eithers (flatMap doesn't execute over Failure)\r\n * Either.of(3).flatMap(a => Either.of(a + 2)).inspect(); // => 'Success(5)'\r\n * Either.Failure(3).flatMap(a => Either.of(null)).inspect(); // => 'Failure(3)'\r\n * Either.of(3).flatMap(a => a + 2); // => 5\r\n *\r\n * // as an applicative functor you can apply Eithers to each other especially using liftA2 or liftA3\r\n * const add = a => b => a + b;\r\n * liftA2(add)(Either.of(2))(Either.of(3)); // => Success(5)\r\n * Either.of(1).map(add).ap(Either.of(2)).inspect(); // => 'Success(3)'\r\n * Either.Failure(1).map(add).ap(Either.of(2)).inspect(); // => 'Failure(1)'\r\n * Either.of(add).ap(Either.of(1)).ap(Either.of(2)).inspect(); // => 'Success(3)'\r\n */\r\nexport const Either = {\r\n  of: value => Success(value),\r\n  Success: value => Success(value),\r\n  Failure: value => Failure(value),\r\n  try: fn => {\r\n    try {\r\n      return Success(fn());\r\n    } catch(e) {\r\n      return Failure(e.message);\r\n    }\r\n  }\r\n};\r\n\r\nconst Failure = value => ({\r\n  value: value,\r\n  inspect: () => `Failure(${deepInspect(value)})`,\r\n  isFailure: () => true,\r\n  isSuccess: () => false,\r\n  map: () => Failure(value),\r\n  flatMap: () => Failure(value),\r\n  ap: () => Failure(value)\r\n});\r\n\r\nconst Success = value => ({\r\n  value: value,\r\n  inspect: () => `Success(${deepInspect(value)})`,\r\n  isFailure: () => false,\r\n  isSuccess: () => true,\r\n  map: fn => Either.of(fn(value)),\r\n  flatMap: fn => fn(value),\r\n  ap: f => f.map(value)\r\n});\r\n\r\n/**\r\n * either outputs result of a function onRight if input Either is Success or outputs result of a function onLeft if input Either is Failure.\r\n *\r\n * either can be called both as a curried unary function or as a standard ternary function.\r\n *\r\n * @HindleyMilner either :: (a -> b) -> (b -> c) -> Either\r\n *\r\n * @pure\r\n * @param {function} onFailure\r\n * @param {function} onSuccess\r\n * @param {Either} functorEither\r\n * @return {*}\r\n *\r\n * @example\r\n * import {either, Either} from '@7urtle/lambda';\r\n *\r\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.of('abc')); // => 'success abc'\r\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.Failure('failure')); // => 'error failure'\r\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.try(() => throw 'failure')); // => 'error failure'\r\n *\r\n * // either can be called both as a curried unary function or as a standard ternary function\r\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.of('abc')) === either(a => 'error ' + a, a => 'success ' + a, Either.of('abc'));\r\n */\r\nexport const either = nary(onFailure => onSuccess => functorEither =>\r\n  functorEither.isFailure()\r\n    ? onFailure(functorEither.value)\r\n    : onSuccess(functorEither.value));","import {deepInspect} from \"./utils\";\r\n\r\n/**\r\n * SyncEffect is a monad that allows you to safely work with synchronous side effects in JavaScript.\r\n *\r\n * SyncEffect expects as its input a function.\r\n *\r\n * SyncEffect is evaluated lazily and nothing is executed until a trigger function is called. It does not have any inner error/exception handling\r\n * mechanism for the effects of the trigger. Consider using the monads Maybe and Either for managing\r\n * the results of the trigger.\r\n *\r\n * In other languages and framework, SyncEffect can be also called the IO monad.\r\n *\r\n * @example\r\n * import {SyncEffect, log, upperCaseOf, liftA2, Either, isNull} from '@7urtle/lambda';\r\n *\r\n * // we create SyncEffect that expects a number from 0 to 1\r\n * // and based on that, it returns a value or throws an error\r\n * const throwError = () => {throw 'random failure'};\r\n * const dangerousFunction = value => value > 0.5 ? 'random success' : throwError();\r\n * const mySyncEffect = SyncEffect.of(dangerousFunction);\r\n *\r\n * // when you are ready, you can call trigger to trigger the side effect\r\n * // nothing is executed until the trigger is called\r\n * mySyncEffect.trigger(Math.random());\r\n * // => returns 'random success' or throws 'random failure' depending on Math.random() value\r\n *\r\n * // you can inspect SyncEffect by\r\n * mySyncEffect.inspect(); // => \"SyncEffect(function...\r\n *\r\n * // as a functor the value inside is safely mappable\r\n * // map doesn't execute in case of an error and nothing executes until a trigger is called\r\n * mySyncEffect\r\n * .map(value => upperCaseOf(value))\r\n * .trigger(Math.random());\r\n * // => returns 'RANDOM SUCCESS' or throws 'random failure' depending on Math.random() value\r\n *\r\n * // as a monad SyncEffect can be safely flat mapped with other SyncEffects\r\n * // flatMap doesn't execute in case of an error and nothing executes until a trigger is called\r\n * SyncEffect.of(() => '7turtle').flatMap(a => SyncEffect.of(() => a + 's')).trigger();\r\n * // => '7urtles'\r\n * SyncEffect.of(() => {throw 'error'}).flatMap(a => SyncEffect.of(() => a + 's')).trigger();\r\n * // => throws 'error'\r\n *\r\n * // as an applicative functor you can apply SyncEffects to each other especially using liftA2 or liftA3\r\n * const add = a => b => a + b;\r\n * liftA2(add)(SyncEffect.of(() => 1)(SyncEffect.of(() => 2)).trigger(); // => 3\r\n * SyncEffect.of(() => add).ap(SyncEffect.of(() => 1)).ap(SyncEffect.of(() => 2)).trigger(); // => 3\r\n *\r\n * // in practice you can use SyncEffect to work for example with DOM\r\n * const DOMSyncEffect = SyncEffect.of(targetID => document.querySelector(targetID));\r\n * const TopOffsetSyncEffect = DOMSyncEffect.map(a => a.offsetTop);\r\n * const ClientHeightSyncEffect = DOMSyncEffect.map(a => a.clientHeight);\r\n *\r\n * TopOffsetSyncEffect.trigger('article'); // 1280\r\n * Either.try(ClientHeightSyncEffect.trigger('#dontexist')); // Failure('Uncaught TypeError: Cannot read property 'offsetTop' of null')\r\n */\r\nexport const SyncEffect = {\r\n  of: trigger => getSyncEffect(trigger)\r\n};\r\n\r\nconst getSyncEffect = trigger => ({\r\n  trigger: trigger,\r\n  inspect: () => `SyncEffect(${deepInspect(trigger)})`,\r\n  map: fn => getSyncEffect(a => fn(trigger(a))),\r\n  flatMap: fn => getSyncEffect(() => getSyncEffect(trigger).map(fn).trigger().trigger()),\r\n  ap: f => getSyncEffect(trigger).flatMap(fn => f.map(fn))\r\n});","import {deepInspect} from \"./utils\";\r\nimport {nary} from \"./arity\";\r\nimport {isFunction} from \"./conditional\";\r\n\r\n/**\r\n * AsyncEffect is a monad that allows you to safely work with asynchronous side effects in JavaScript.\r\n *\r\n * AsyncEffect expects as its input a function that takes two inputs of a reject function, and a resolve\r\n * function. Reject function is called on failure and resolve function is called on success. It is similar\r\n * to using JavaScript Promise and AsyncEffect can be directly created from a Promise turning it into a monad.\r\n *\r\n * AsyncEffect is evaluated lazily and nothing is executed until a trigger function is called.\r\n *\r\n * AsyncEffect can also be called Future monad in other libraries or languages.\r\n *\r\n * @example\r\n * import {AsyncEffect, log, upperCaseOf, liftA2, liftA3} from '@7urtle/lambda';\r\n *\r\n * // we create AsyncEffect that expects a number from 0 to 1\r\n * // and based on that, it resolve or rejects 10 milliseconds after it is triggered\r\n * const myAsyncEffect = AsyncEffect\r\n * .of(reject => resolve =>\r\n *     setTimeout(() => Math.random() > 0.5 ? resolve('random success') : reject('random failure'), 10)\r\n * );\r\n *\r\n * // we could also create AsyncEffect from a JavaScript Promise\r\n * const myPromise = new Promise((resolve, reject) =>\r\n *     setTimeout(() => Math.random() > 0.5 ? resolve('random success') : reject('random failure'), 10)\r\n * );\r\n * const promiseAsyncEffect = AsyncEffect.ofPromise(myPromise);\r\n *\r\n * // you can inspect AsyncEffect by\r\n * myAsyncEffect.inspect(); // => \"AsyncEffect(function...\r\n *\r\n * // when you are ready, you can call trigger to trigger the side effect\r\n * // nothing is executed until the trigger is called\r\n * myAsyncEffect\r\n * .trigger\r\n * (error => log(error))\r\n * (result => log(result));\r\n * // => logs 'random success' or 'random failure' depending on Math.random() value\r\n *\r\n * // you can also turn AsyncEffect into a JavaScript Promise\r\n * myAsyncEffect\r\n * .promise()\r\n * .then(result => log(result), error => log(error));\r\n * // => logs 'random success' or 'random failure' depending on Math.random() value\r\n *\r\n * // thrown exceptions lead AsyncEffect to reject\r\n * AsyncEffect\r\n * .of(() => {\r\n *     throw 'error';\r\n * })\r\n * .trigger(log)(log);\r\n * // => logs 'error'\r\n *\r\n * // as a functor the value inside is safely mappable\r\n * // map doesn't execute in case of an error and nothing executes until a trigger is called\r\n * myAsyncEffect\r\n * .map(value => upperCaseOf(value))\r\n * .trigger(log)(log);\r\n * // => logs 'RANDOM SUCCESS' or 'random failure' depending on Math.random() value\r\n *\r\n * // as a monad AsyncEffect can be safely flat mapped with other AsyncEffects\r\n * // flatMap doesn't execute in case of an error and nothing executes until a trigger is called\r\n * AsyncEffect\r\n * .of(reject => resolve => resolve('7urtle'))\r\n * .flatMap(a => AsyncEffect.of(reject => resolve => resolve(a + 's')))\r\n * .trigger(log)(log);\r\n * // => logs '7urtles'\r\n *\r\n * // as an applicative functor you can apply AsyncEffects to each other especially using liftA2 or liftA3\r\n * const add = a => b => a + b;\r\n * const AS1 = AsyncEffect.of(reject => resolve => resolve(1));\r\n * const AS2 = AsyncEffect.of(reject => resolve => resolve(2));\r\n * liftA2(add)(AS1)(AS2); // => resolve(3)\r\n *\r\n * const ASFail = AsyncEffect.of(() => {throw 'error'});\r\n * liftA3(add)(ASFail)(AS1)(AS2); // => reject('error')\r\n *\r\n * // AsyncEffect.of as well as AsyncEffect.trigger accept both curried and binary functions\r\n * AsyncEffect.of((reject, resolve) => resolve('7urtle')).trigger(log, log); // logs '7urtle'\r\n *\r\n * // as an example you can use AsyncEffect to help you work with axios or fs\r\n *\r\n * // axios example\r\n * import axios from 'axios';\r\n * const getFromURL = url => AsyncEffect.ofPromise(axios.get(url));\r\n *\r\n * getFromURL('/my/ajax/url')\r\n * .trigger\r\n * (error => log(error))\r\n * (result => log(result.data));\r\n *\r\n * // reading file example\r\n * import fs from 'fs';\r\n * const readFile => input =>\r\n *     AsyncEffect\r\n *     .of(reject => resolve =>\r\n *         fs.readFile(input, (err, data) =>\r\n *             err ? reject(err) : resolve(data)\r\n *         )\r\n *     );\r\n *\r\n * readFile('./file.txt')\r\n * .trigger\r\n * (error => log(error))\r\n * (result => log(result));;\r\n */\r\nexport const AsyncEffect = {\r\n  of: trigger => getAsyncEffect(nary(reject => resolve => {\r\n    try {\r\n      const result = trigger(reject, resolve);\r\n      return isFunction(result) ? result(resolve) : result;\r\n    } catch(error) {\r\n      reject(error);\r\n    }\r\n  })),\r\n  ofPromise: promise => AsyncEffect.of(reject => resolve =>\r\n      promise.then(resolve).catch(reject)\r\n  )\r\n};\r\n\r\nconst getAsyncEffect = trigger => ({\r\n  trigger: trigger,\r\n  inspect: () => `AsyncEffect(${deepInspect(trigger)})`,\r\n  promise: () => new Promise((resolve, reject) => trigger(reject)(resolve)),\r\n  map: fn => getAsyncEffect(nary(reject => resolve => trigger(reject)(a => resolve(fn(a))))),\r\n  flatMap: fn => getAsyncEffect(nary(reject => resolve => trigger(reject)(x => fn(x).trigger(reject)(resolve)))),\r\n  ap: f => getAsyncEffect(trigger).flatMap(fn => f.map(fn))\r\n});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(66);\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"sourceRoot":""}