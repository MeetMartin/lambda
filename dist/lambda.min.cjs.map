{"version":3,"file":"lambda.min.cjs","mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAW,EAAID,IAEfD,EAAQ,EAAIC,IARd,CASGK,MAAM,WACT,M,mBCTA,IAAIC,EAAsB,CCA1BA,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3EF,EAAwB,CAACQ,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClFT,EAAyBL,IACH,oBAAXkB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeV,EAASkB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeV,EAAS,aAAc,CAAEoB,OAAO,M,8rECUhD,IAAMC,EAAO,SAAAC,GAAE,OAClB,sCAAIC,EAAJ,yBAAIA,EAAJ,uBAA6B,IAAhBA,EAAKC,OACZF,IACAC,EAAKE,QACH,SAACC,EAAaC,GAAd,OAA0BD,EAAYC,KACtCL,KAkBCM,EAAQ,SAARA,EAAQN,GAAE,OACnB,sCAAIC,EAAJ,yBAAIA,EAAJ,uBAAaA,EAAKC,QAAUF,EAAGE,OACzBF,EAAE,WAAF,EAAMC,GACN,sCAAIM,EAAJ,yBAAIA,EAAJ,uBAAcD,EAAMN,GAAN,aAAaC,EAAb,OAAsBM,OCzC/B,SAASC,EAAkBC,EAAKC,IAClC,MAAPA,GAAeA,EAAMD,EAAIP,UAAQQ,EAAMD,EAAIP,QAE/C,IAAK,IAAIS,EAAI,EAAGC,EAAO,IAAIC,MAAMH,GAAMC,EAAID,EAAKC,IAC9CC,EAAKD,GAAKF,EAAIE,GAGhB,OAAOC,ECHM,SAASE,EAAmBL,GACzC,OCJa,SAA4BA,GACzC,GAAII,MAAME,QAAQN,GAAM,OAAO,EAAiBA,GDGzC,CAAkBA,IELZ,SAA0BO,GACvC,GAAsB,oBAAXpB,QAAmD,MAAzBoB,EAAKpB,OAAOqB,WAA2C,MAAtBD,EAAK,cAAuB,OAAOH,MAAMK,KAAKF,GFInF,CAAgBP,IGJpC,SAAqCvB,EAAGiC,GACrD,GAAKjC,EAAL,CACA,GAAiB,iBAANA,EAAgB,OAAO,EAAiBA,EAAGiC,GACtD,IAAIC,EAAIjC,OAAOM,UAAU4B,SAAS1B,KAAKT,GAAGoC,MAAM,GAAI,GAEpD,MADU,WAANF,GAAkBlC,EAAEqC,cAAaH,EAAIlC,EAAEqC,YAAYC,MAC7C,QAANJ,GAAqB,QAANA,EAAoBP,MAAMK,KAAKhC,GACxC,cAANkC,GAAqB,2CAA2CK,KAAKL,GAAW,EAAiBlC,EAAGiC,QAAxG,GHFyD,CAA2BV,IILvE,WACb,MAAM,IAAIiB,UAAU,wIJIwE,GKL/E,SAASC,EAAQpC,GAG9B,OAAOoC,EAAU,mBAAqB/B,QAAU,iBAAmBA,OAAOqB,SAAW,SAAU1B,GAC7F,cAAcA,GACZ,SAAUA,GACZ,OAAOA,GAAO,mBAAqBK,QAAUL,EAAIgC,cAAgB3B,QAAUL,IAAQK,OAAOH,UAAY,gBAAkBF,GACvHoC,EAAQpC,GCqBL,IAAMqC,EAAM,sCAAIC,EAAJ,yBAAIA,EAAJ,uBAAmB,SAAAC,GAAQ,OAAIC,IAAQ,SAAAC,GAAS,OAAIA,EAAUF,KAA/BC,CAA0CF,KA0B/EI,EAAK,sCAAIJ,EAAJ,yBAAIA,EAAJ,uBAAmB,SAAAC,GAAQ,OAAII,IAAO,SAAAF,GAAS,OAAIA,EAAUF,KAA9BI,CAAyCL,KA4B9EM,EAAUpC,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAID,IAAMC,MA4B/BC,EAAavC,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAID,IAAMC,MA4BlCE,EAAcxC,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAIF,EAAQK,GAAYJ,GAApBD,CAAwBK,GAAYH,QA4BjEI,EAAiB1C,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAIC,EAAWE,GAAYJ,GAAvBE,CAA2BE,GAAYH,QAiBvEK,EAASP,GAAQ,GAiBjBQ,EAAUR,GAAQ,GAuBlBS,EAAgB7C,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAIA,EAAID,MAuBnCS,EAAa9C,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAIA,EAAID,MAwBhCU,EAAY/C,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAIA,GAAKD,MAwBhCW,EAAWhD,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAIA,GAAKD,MA0B/BY,EAAYjD,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAI,SAAAY,GAAC,OACrCb,EAAIC,EACFD,EAAIa,GAAKZ,EAAIY,EACbb,EAAIa,GAAKZ,EAAIY,OA2BLC,EAAYnD,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAI,SAAAY,GAAC,OACtCb,EAAIC,EACFD,GAAKa,GAAKZ,GAAKY,EACfb,GAAKa,GAAKZ,GAAKY,OAwBRE,EAAWpD,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAIF,EAAQiB,GAAOf,GAAfF,CAAmBC,OAuB7CiB,EAActD,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAIC,EAAWc,GAAOf,GAAlBC,CAAsBF,OAiBnDkB,EAAWH,EAAS,UAiBpBI,EAAcF,EAAY,UAiB1BG,EAAYL,EAAS,WAiBrBM,EAAeJ,EAAY,WAiB3BK,EAASvB,EAAQ,MAiBjBwB,EAAYrB,EAAW,MAiBvBsB,EAAcT,EAAS,aAiBvBU,EAAiBR,EAAY,aAiB7BS,EAAWX,EAAS,UAiBpBY,EAAcV,EAAY,UAmB1BW,EAAWb,EAAS,UAmBpBc,EAAcZ,EAAY,UAiB1BtC,EAAUF,MAAME,QAiBhBmD,EAAa,SAAA9B,GAAC,OAAKvB,MAAME,QAAQqB,IAiBjC+B,EAAahB,EAAS,YAiBtBiB,EAAgBf,EAAY,YAmB5BgB,EAAWtE,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAIF,EAAQmC,GAASjC,GAAjBF,CAAqBC,OAuB/CmC,EAAcxE,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAKgC,EAASjC,EAATiC,CAAYhC,OAgB1CmC,EAAY,SAAA1C,GAAQ,MACT,oBAAZ2C,SAA2B3C,aAAoB2C,SAC9B,oBAAjBC,cAAgC5C,aAAoB4C,cAgBnDC,EAAe,SAAA7C,GAAQ,OAAK0C,EAAU1C,IAoBtC8C,EAAU,SAAA9C,GAAQ,OAC3BuC,EAAS,EAATA,CAAYvC,IACZ6C,EAAa7C,MACZkC,EAASlC,IAAYuC,EAAS,EAATA,CAAYlF,OAAO0F,oBAAoB/C,KAoBpDgD,EAAa,SAAAhD,GAAQ,OAAK8C,EAAQ9C,IAiBlCiD,EAAS5C,EAAQ,GAiBjB6C,EAAY1C,EAAW,GAyBvB2C,EAAY,SAAAnD,GAAQ,OAC7BA,GAAYA,EAASmD,UACnBnD,EAASmD,YACTvB,EAAO5B,IAAa8B,EAAY9B,IAAa8C,EAAQ9C,IAwB9CoD,EAAS,SAAApD,GAAQ,OACzBmD,EAAUnD,IA4BFqD,EAAOpF,GAAK,SAAAiC,GAAS,OAAI,SAAAoD,GAAU,OAAI,SAAAtD,GAAQ,OACxDE,EAAUF,GACRsD,EAAWtD,GACXA,OA6BOuD,EAAStF,GAAK,SAAAiC,GAAS,OAAI,SAAAsD,GAAW,OAAI,SAAAxD,GAAQ,OAC3DE,EAAUF,GACRA,EACAwD,EAAYxD,QAgCJyD,EAASxF,GAAK,SAAAiC,GAAS,OAAI,SAAAoD,GAAU,OAAI,SAAAE,GAAW,OAAI,SAAAxD,GAAQ,OAC1EE,EAAUF,GACRsD,EAAWtD,GACXwD,EAAYxD,SCp9BH,SAAS0D,EAAgBjG,EAAKN,EAAKa,GAYhD,OAXIb,KAAOM,EACTJ,OAAOC,eAAeG,EAAKN,EAAK,CAC9Ba,MAAOA,EACPT,YAAY,EACZoG,cAAc,EACdC,UAAU,IAGZnG,EAAIN,GAAOa,EAGNP,E,gkBCQF,IAAMoG,GAAW,SAAA7D,GAAQ,OAAIA,GA2BvB8D,GAAU,sCAAIC,EAAJ,yBAAIA,EAAJ,uBAAY,SAAA/D,GAAQ,OAAIgE,GAAYhE,EAAZgE,EAAsB,SAACC,EAAGC,GAAJ,OAAUA,EAAED,KAAlCD,CAAsCD,KA2BxEI,GAAO,sCAAIJ,EAAJ,yBAAIA,EAAJ,uBAAY,SAAA/D,GAAQ,OAAI3B,GAAO2B,EAAP3B,EAAiB,SAAC4F,EAAGC,GAAJ,OAAUA,EAAED,KAA7B5F,CAAiC0F,KAyChEK,GAAMnG,GAAK,SAAAoG,GAAM,OAAI,SAAArE,GAAQ,OACtCA,GAAYA,EAASoE,IACnBpE,EAASoE,IAAIC,GACbA,EAAOrE,OAgCAsE,GAAUrG,GAAK,SAAAC,GAAE,OAAI,SAAAqG,GAAO,OAAIA,EAAQD,QAAQpG,OA+BhDsG,GAASvG,GAAK,SAAAC,GAAE,OAAI,SAAAuG,GAAG,OAAI,SAAAC,GAAG,OAAID,EAAIL,IAAIlG,GAAIyG,GAAGD,QAgCjDE,GAAS3G,GAAK,SAAAC,GAAE,OAAI,SAAAuG,GAAG,OAAI,SAAAC,GAAG,OAAI,SAAAG,GAAG,OAAIJ,EAAIL,IAAIlG,GAAIyG,GAAGD,GAAKC,GAAGE,SAyBhEC,GAAS7G,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAC7BiB,EAASjB,IAAMtB,EAAQsB,GACjBA,EAAEuE,OAAOxE,GACT4B,EAAS3B,GAAT,SACSA,GAAMD,QACXyE,MA8BDC,GAAQ,SAARA,IAAQ,2BAAIC,EAAJ,yBAAIA,EAAJ,uBACjB5G,GACK,GADLA,EAEK,SAAC6G,EAAK3G,GAAN,OACGU,EAAQV,GAAR,YACU2G,GADV,EACkB3G,IACZ2D,EAAS3D,GACLF,GACG6G,EADH7G,EAEG,SAACiC,EAAGa,GAAJ,OACGe,EAAS3D,EAAQ4C,KAAOA,KAAK+D,EAA7B,SACW5E,GADX,QACea,EAAI6D,EAAME,EAAI/D,GAAI5C,EAAQ4C,MADzC,SAEWb,GAFX,QAEea,EAAI5C,EAAQ4C,OALjC9C,CAOGhB,OAAO0F,oBAAoBxE,IARlC,SASS2G,GAAQ3G,KAd/BF,CAgBK4G,IAwBIE,GAAWlH,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAIA,EAAE4E,SAAS7E,OAyBrC8E,GAAUnH,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAI8E,GAAoB9E,EAAE6E,QAAQ9E,QAwBvDgF,GAAcrH,GAAK,SAAAqC,GAAC,OAAI,SAAAC,GAAC,OAAI8E,GAAoB9E,EAAE+E,YAAYhF,QA4B/DiF,GAAUtH,GAAK,SAAAuH,GAAM,OAAI,SAAAtH,GAAE,OAAI,SAAA8B,GAAQ,OAChDA,KAAYwF,EACNA,EAAOxF,GACPyF,IAAY,SAAAlF,GAAC,OAAIiF,EAAOxF,GAAYO,IAApCkF,CAAuCvH,EAAG8B,SAmCvC0F,GAAO,SAAAxH,GAAE,OAAIqH,GAAQ,GAARA,CAAYrH,IAiBzByH,GAAO,SAAAC,GAAW,MAAMA,GC3axBtE,GAAS,SAAAhB,GAAC,SAAWA,IAkBrBkC,GAAW,SAAAlC,GAAC,OAAIA,EAAElC,QAsBlBqH,GAAcxH,GAAK,SAAAC,GAAE,OAAI,SAAA8B,GAEpC,OADA9B,EAAG8B,GACIA,MAgBI6F,GAAMJ,GAAYK,QAAQD,KAe1BE,GAAMN,IAAY,SAAAnF,GAAC,OAAIwF,QAAQD,IAAInF,GAAYJ,OAqB/C+E,GAAsB,SAAArF,GAAQ,OAAIK,GAAS,EAATA,CAAYL,QAAY+E,EAAW/E,GAwBrEgG,GAAkB,SAAA9H,GAAE,OAAIA,EAAGwB,KAAOxB,EAAGwB,KAAOuG,OAAO/H,IAqBnDgI,GAAe,SAAA5F,GAAC,iBAAQ6F,GAAK,KAALA,CAAW/B,GAAI1D,GAAJ0D,CAAiB9D,IAApC,MAgBhB8F,GAAgB,SAAA9F,GAAC,iBAAQA,EAAR,MAgBjB+F,GAAgB,SAAA/F,GAAC,OAC5B+B,EAAW/B,EAAEgG,SACThG,EAAEgG,UADN,WAEQH,GAAK,KAALA,CAAW/B,GAAI+B,GAAK,MAAT/B,CAAgBA,IAAI,SAAAmC,GAAC,MAAI,CAACA,EAAG7F,GAAYJ,EAAEiG,OAA3BnC,CAAiCoC,GAAOlG,MAF3E,MA0BWI,GAAc,SAAAJ,GAAC,OAC1BwB,EAAYxB,GACR,YACAsB,EAAOtB,GACL,OACA+B,EAAW/B,GACT0F,GAAgB1F,GAChBrB,EAAQqB,GACN4F,GAAa5F,GACb4B,EAAS5B,GACP+F,GAAc/F,GACdkB,EAASlB,GACP8F,GAAc9F,GACd2F,OAAO3F,ICrNVmG,GAAO,SAAAC,GAAM,OAAIA,EAAOD,QAwBxBE,GAAY1I,GAAK,SAAA2I,GAAK,OAAI,SAAAF,GAAM,OAAIE,EAAMjH,KAAK+G,OAyB/CG,GAAS5I,GAAK,SAAA6I,GAAK,OAAI,SAAAC,GAAK,OAAI,SAAAL,GAAM,OAAIA,EAAOG,OAAOE,EAAOD,QAgB/DE,GAAgB,SAAAN,GAAM,OAAIA,EAAOG,OAAO,EAAG,IAgB3CI,GAAe,SAAAP,GAAM,OAAIA,EAAOG,QAAQ,EAAG,IAwB3CK,GAAajJ,GAAK,SAAAkJ,GAAS,OAAI,SAAAT,GAAM,OAAIA,EAAOQ,WAAWC,OAwB3DC,GAAWnJ,GAAK,SAAAkJ,GAAS,OAAI,SAAAT,GAAM,OAAIA,EAAOU,SAASD,OAuBvDE,GAASpJ,GAAK,SAAAqJ,GAAK,OAAI,SAAAZ,GAAM,OAAIA,EAAOW,OAAOC,OAyB/CC,GAAUtJ,GAAK,SAAAuJ,GAAW,OAAI,SAAAL,GAAS,OAAI,SAAAT,GAAM,OAAIA,EAAOa,QAAQJ,EAAWK,QA0B/EC,GAASxJ,GAAK,SAAAkJ,GAAS,OAAI,SAAAT,GAAM,OAAIrB,GAAoBqB,EAAOe,OAAON,QAuBvEO,GAAQzJ,GAAK,SAAAkJ,GAAS,OAAI,SAAAT,GAAM,OAAIA,EAAOgB,MAAMP,OAiBjDQ,GAAc,SAAAjB,GAAM,OAAIA,EAAOkB,eAiB/BC,GAAc,SAAAnB,GAAM,OAAIA,EAAOoB,eCtP/BzJ,GAASJ,GAAK,SAAA8J,GAAO,OAAI,SAAAC,GAAO,OAAI,SAAAC,GAAI,OAAIA,EAAK5J,OAAO2J,EAASD,QA6BjE/D,GAAc/F,GAAK,SAAA8J,GAAO,OAAI,SAAAC,GAAO,OAAI,SAAAC,GAAI,OAAIA,EAAKjE,YAAYgE,EAASD,QA0B3EG,GAASjK,GAAK,SAAAkK,GAAO,OAAI,SAAAF,GAAI,OAAIA,EAAKC,OAAOC,OAiC7CC,GAAYnK,GAAK,SAAAkK,GAAO,OAAI,SAAA9D,GAAM,OAAI,SAAA4D,GAAI,OACnD5J,GAAO,GAAPA,EAAW,SAAC6G,EAAK3G,GAAN,OAAkB4J,EAAQ5J,GAAW2G,EAAImD,KAAKhE,EAAO9F,KAAa2G,EAAMA,IAAnF7G,CAAwF4J,QAyB/EK,GAAOrK,GAAK,SAAAkK,GAAO,OAAI,SAAAF,GAAI,OAAIA,EAAKK,KAAKH,OAyBzCI,GAAYtK,GAAK,SAAAkK,GAAO,OAAI,SAAAF,GAAI,OAAI5C,GAAoB4C,EAAKM,UAAUJ,QA0BvEhC,GAAOlI,GAAK,SAAAuK,GAAS,OAAI,SAAAP,GAAI,OAAIA,EAAK9B,KAAKqC,OAiB3ChC,GAASnJ,OAAOoL,KAiBhBC,GAAYrL,OAAOsL,QAuBnB1I,GAAUhC,GAAK,SAAAkK,GAAO,OAAI,SAAAF,GAAI,OAAIA,EAAKW,MAAMT,OA2B7C3I,GAAQvB,GAAK,SAAA4K,GAAG,OAAI,SAAA9B,GAAK,OAAI,SAAAkB,GAAI,OAAIA,EAAKzI,MAAMuH,EAAO8B,QAuBvDzI,GAASnC,GAAK,SAAAkK,GAAO,OAAI,SAAAF,GAAI,OAAIA,EAAKa,KAAKX,OAuB3CY,GAAO9K,GAAK,SAAA+K,GAAO,OAAI,SAAAf,GAAI,OAAI,EAAIA,GAAMc,KAAKC,OAgB9CC,GAAqBF,IAAK,SAACzI,EAAGC,GAAJ,OAAW,SAAAD,GAAC,OAAI,SAAAC,GAAC,OAAID,EAAIC,GAAK,EAAID,EAAIC,EAAI,EAAI,GAAnC,CAAsCsH,GAAYvH,GAAlD,CAAsDuH,GAAYtH,OAgBvG2I,GAAuBH,IAAK,SAACzI,EAAGC,GAAJ,OAAW,SAAAD,GAAC,OAAI,SAAAC,GAAC,OAAID,EAAIC,EAAI,EAAID,EAAIC,GAAK,EAAI,GAAnC,CAAsCsH,GAAYvH,GAAlD,CAAsDuH,GAAYtH,OAgBzG4I,GAAkBJ,IAAK,SAACzI,EAAGC,GAAJ,OAAUD,EAAIC,KAgBrC6I,GAAoBL,IAAK,SAACzI,EAAGC,GAAJ,OAAUA,EAAID,KAkBvC+I,GAAS,SAAApB,GAAI,OAAIA,EAAK,IAkBtBqB,GAAS,SAAArB,GAAI,OAAIA,EAAKzI,MAAM,IAkB5B+J,GAAS,SAAAtB,GAAI,OAAIzI,GAAMgD,GAASyF,GAAO,EAAtBzI,CAAyB,EAAzBA,CAA4ByI,IAkB7CuB,GAAS,SAAAvB,GAAI,OAAIA,EAAKzF,GAASyF,GAAO,IA0BtCwB,GAAUxL,GAAK,SAAAC,GAAE,OAAI,SAAA+J,GAAI,OAClC5J,GACC,GADDA,EAEC,SAAC6G,EAAK3G,GAAN,OACI2G,EAAIhH,EAAGK,IAAY2G,EAAIhH,EAAGK,KAAa,IAAI8J,KAAK9J,IAAY2G,IAHjE7G,CAKC4J,OAkBQyB,GAAW,SAAAzB,GAAI,OAAIA,EAAK0B,KAAKC,MAAMD,KAAKE,SAAWrH,GAASyF,MCvd5D6B,GAAO,CAClBC,GAAI,SAAAC,GAAK,OAAIC,GAAS,SAAAD,GAAK,OAAI,SAAA1J,GAAC,OAAI0J,EAAMxM,IAAI8C,IAAM0J,EAAMxM,IAAI,WAAQuH,GAAhD,CAA2D,IAAImF,IAAIF,OAGrFC,GAAU,SAAVA,EAAUD,GAAK,MAAK,CACxBA,MAAOA,EACP1D,QAAS,gCAAc5F,GAAYsJ,GAA1B,MACT5F,IAAK,SAAAlG,GAAE,OAAI+L,GAAQ,SAAA3J,GAAC,OAAK6J,EAAqDH,EAAM1J,GAAjDwB,EAAYqI,GAAUA,EAASjM,EAAGiM,GAA5C,IAAAA,MACzB7F,QAAS,SAAApG,GAAE,OAAI+L,GAAQ,SAAA3J,GAAC,OAAK6J,EAA6DF,EAAQD,GAAO5F,IAAIlG,GAAI8L,MAAM1J,GAAhFwB,EAAYqI,QAAUpF,EAAYoF,EAAOH,MAAM1J,GAAzD,IAAA6J,MAC7BxF,GAAI,SAAAT,GAAC,OAAI+F,EAAQD,GAAO1F,SAAQ,SAAApG,GAAE,OAAIgG,EAAEE,IAAIlG,SC4DjCkM,GAAc,CACzBL,GAAI,SAAAM,GAAO,OAAIC,GAAerM,GAAK,SAAAsM,GAAM,OAAI,SAAAC,GAC3C,IACE,IAAML,EAASE,EAAQE,EAAQC,GAC/B,OAAOnI,EAAW8H,GAAUA,EAAOK,GAAWL,EAC9C,MAAMvE,GACN2E,EAAO3E,UAGX6E,UAAW,SAAAC,GAAO,OAAIN,GAAYL,IAAG,SAAAQ,GAAM,OAAI,SAAAC,GAAO,OAClDE,IAAUC,KAAKH,GAAf,MAA8BD,SAI9BD,GAAiB,SAAjBA,EAAiBD,GAAO,MAAK,CACjCA,QAASA,EACT/D,QAAS,uCAAqB5F,GAAY2J,GAAjC,MACTK,QAAS,kBAAM,IAAIE,SAAQ,SAACJ,EAASD,GAAV,OAAqBF,EAAQE,EAARF,CAAgBG,OAChEpG,IAAK,SAAAlG,GAAE,OAAIoM,EAAerM,GAAK,SAAAsM,GAAM,OAAI,SAAAC,GAAO,OAAIH,EAAQE,EAARF,EAAgB,SAAA/J,GAAC,OAAIkK,EAAQtM,EAAGoC,aACpFgE,QAAS,SAAApG,GAAE,OAAIoM,EAAerM,GAAK,SAAAsM,GAAM,OAAI,SAAAC,GAAO,OAAIH,EAAQE,EAARF,EAAgB,SAAAQ,GAAC,OAAI3M,EAAG2M,GAAGR,QAAQE,EAAdrM,CAAsBsM,YACnG7F,GAAI,SAAAT,GAAC,OAAIoG,EAAeD,GAAS/F,SAAQ,SAAApG,GAAE,OAAIgG,EAAEE,IAAIlG,SA6B1C4M,GAAoB,sCAAIC,EAAJ,yBAAIA,EAAJ,uBAC/BX,GACCK,WACG,kBAAMG,QAAQI,IAAI5G,IAAI,SAAA9D,GAAC,OAAIA,EAAEoK,YAAXtG,CAAsB2G,QCtGjCE,GAAa,CACxBlB,GAAI,SAAAM,GAAO,OAAIa,GAAcb,KAGzBa,GAAgB,SAAhBA,EAAgBb,GAAO,MAAK,CAChCA,QAASA,EACT/D,QAAS,sCAAoB5F,GAAY2J,GAAhC,MACTjG,IAAK,SAAAlG,GAAE,OAAIgN,GAAc,SAAA5K,GAAC,OAAIpC,EAAGmM,EAAQ/J,QACzCgE,QAAS,SAAApG,GAAE,OAAIgN,GAAc,kBAAMA,EAAcb,GAASjG,IAAIlG,GAAImM,UAAUA,cAC5E1F,GAAI,SAAAT,GAAC,OAAIgH,EAAcb,GAAS/F,SAAQ,SAAApG,GAAE,OAAIgG,EAAEE,IAAIlG,SAoBzCiN,GAAoB,SAAAC,GAC/B,IACE,OAAOC,GAAMtB,GAAGqB,EAAgBf,WAChC,MAAMzE,GACN,OAAO0F,KAoBEC,GAAqB,SAAAH,GAAe,OAAII,GAAAA,IAAWJ,EAAgBf,UAkBlEoB,GAA0B,SAAAL,GAAe,OACrDhB,GAAAA,IACI,SAAAsB,GAAC,OAAI,SAAAlB,GAAO,OACdA,EAAQY,EAAgBf,gBC/HfsB,GAAU,SAAA3N,GAAK,MAAK,CAC/BA,MAAOA,EACPsI,QAAS,mCAAiB5F,GAAY1C,GAA7B,MACT4N,UAAW,kBAAM,GACjBC,UAAW,kBAAM,GACjBzH,IAAK,kBAAMuH,GAAQ3N,IACnBsG,QAAS,kBAAMqH,GAAQ3N,IACvB8N,SAAU,SAAA5N,GAAE,OAAIyN,GAAQzN,EAAGF,KAC3B+N,MAAO9N,GAAK,SAAA+N,GAAM,OAAI,SAAAN,GAAC,OAAIC,GAAQK,EAAOhO,QAC1C2G,GAAI,kBAAMgH,GAAQ3N,IAClBiO,KAAM,SAAA3L,GAAC,OAAI4L,GAAQ5L,IACnB6L,OAAQ,SAAAjO,GAAE,OAAIA,KACdkO,MAAO,SAAAlO,GAAE,OAAIsN,GAAM,IAAKtN,MAGbgO,GAAU,SAAAlO,GAAK,MAAK,CAC/BA,MAAOA,EACPsI,QAAS,mCAAiB5F,GAAY1C,GAA7B,MACT4N,UAAW,kBAAM,GACjBC,UAAW,kBAAM,GACjBzH,IAAK,SAAAlG,GAAE,OAAIgO,GAAQhO,EAAGF,KACtB8N,SAAU,kBAAMI,GAAQlO,IACxB+N,MAAO9N,GAAK,SAAAyN,GAAC,OAAI,SAAAW,GAAO,OAAIH,GAAQG,EAAQrO,QAC5CsG,QAAS,SAAApG,GAAE,OAAIA,EAAGF,IAClB2G,GAAI,SAAA2H,GAAC,OAAIA,EAAElI,IAAIpG,IACfiO,KAAM,kBAAMC,GAAQlO,IACpBmO,OAAQ,kBAAMD,GAAQlO,IACtBoO,MAAO,kBAAMF,GAAQlO,MA2FVwN,GAAS,CACpBzB,GAAI,SAAA/L,GAAK,OAAIkO,GAAQlO,IACrBkO,QAAS,SAAAlO,GAAK,OAAIkO,GAAQlO,IAC1B2N,QAAS,SAAA3N,GAAK,OAAI2N,GAAQ3N,IAC1BuO,IAAK,SAAArO,GACH,IACE,OAAOgO,GAAQhO,KACf,MAAM0H,GACN,OAAO+F,GAAQ/F,EAAM4G,SAAW5G,MA4BzB6G,GAASxO,GAAK,SAAAyO,GAAS,OAAI,SAAAC,GAAS,OAAI,SAAAC,GAAa,OAChEA,EAAchB,YACVc,EAAUE,EAAc5O,OACxB2O,EAAUC,EAAc5O,YAoBjB6O,GAAe,sCAAIC,EAAJ,yBAAIA,EAAJ,uBAC1BzO,GACC6N,GAAQ,IADT7N,EAEC,SAACC,EAAaC,GAAd,OACCA,EAAQqN,YACNtN,EAAYsN,YACVD,GAAQ,GAAD,SAAKrN,EAAYN,OAAjB,CAAwBO,EAAQP,SACvC2N,GAAQ,CAACpN,EAAQP,QACnBM,EAAYsN,YACVtN,EACA4N,GAAQ,GAAD,SAAK5N,EAAYN,OAAjB,CAAwBO,EAAQP,WAT7CK,CAWCyO,IAkCUC,GAAkB,sCAAIhJ,EAAJ,yBAAIA,EAAJ,uBAAY,SAAAiJ,GAAK,OAC9C3O,GACC6N,GAAQc,GADT3O,EAEC,SAACC,EAAa2O,GAAd,OACEC,EAMCD,EAAUD,IALIpB,YACZtN,EAAYsN,YACVD,GAAQ,GAAD,SAAKrN,EAAYN,OAAjB,CAAwBkP,EAAclP,SAC7C2N,GAAQ,CAACuB,EAAclP,QACzBM,EALH,IAAA4O,IAHH7O,CAWC0F,KAoBUoJ,GAAgB,SAAAC,GAAW,OACtCX,IACC,kBAAMnB,KADPmB,EAEC,SAAAzO,GAAK,OAAIqN,GAAMtB,GAAG/L,KAFnByO,CAGCW,IAkBUC,GAAqB,SAAAD,GAAW,OAC3CX,IACC,SAAA7G,GAAK,OAAIqF,GAAWlB,IAAG,WAAQ,MAAMnE,OADtC6G,EAEC,SAAAzO,GAAK,OAAIiN,GAAWlB,IAAG,kBAAM/L,OAF9ByO,CAGCW,IAkBUE,GAAsB,SAAAF,GAAW,OAC5CX,IACC,SAAA7G,GAAK,OAAIwE,GAAYL,IAAG,SAAAQ,GAAM,OAAI,SAAAmB,GAAC,OAAInB,EAAO3E,SAD/C6G,EAEC,SAAAzO,GAAK,OAAIoM,GAAYL,IAAG,SAAA2B,GAAC,OAAI,SAAAlB,GAAO,OAAIA,EAAQxM,SAFjDyO,CAGCW,IC9SU9B,GAAU,CACrBtN,MAAO,KACPsI,QAAS,iBAAM,WACfnD,UAAW,kBAAM,GACjBC,OAAQ,kBAAM,GACdgB,IAAK,kBAAMkH,IACXhH,QAAS,kBAAMgH,IACf3G,GAAI,kBAAM2G,KAGCiC,GAAO,SAAAvP,GAAK,MAAK,CAC5BA,MAAOA,EACPsI,QAAS,gCAAc5F,GAAY1C,GAA1B,MACTmF,UAAW,kBAAM,GACjBC,OAAQ,kBAAM,GACdgB,IAAK,SAAAlG,GAAE,OAAImN,GAAMtB,GAAG7L,EAAGF,KACvBsG,QAAS,SAAApG,GAAE,OAAIA,EAAGF,IAClB2G,GAAI,SAAAT,GAAC,OAAIA,EAAEE,IAAIpG,MAqFJqN,GAAQ,CACnBtB,GAAI,SAAA/L,GAAK,OAAImF,EAAUnF,GAASsN,GAAUiC,GAAKvP,IAC/CuP,KAAM,SAAAvP,GAAK,OAAIuP,GAAKvP,IACpBsN,QAASA,IA0BEkC,GAAQvP,GAAK,SAAAwP,GAAS,OAAI,SAAAC,GAAM,OAAI,SAAAC,GAAY,OAC3DA,EAAaxK,YACTsK,IACAC,EAAOC,EAAa3P,YAmBb4P,GAAc,sCAAIC,EAAJ,yBAAIA,EAAJ,uBACzBxP,GACCkP,GAAK,IADNlP,EAEC,SAACC,EAAaC,GAAd,OACCA,EAAQ4E,aAEN7E,EAAY6E,YADZmI,GAGEiC,GAAK,GAAD,SAAKjP,EAAYN,OAAjB,CAAwBO,EAAQP,WAP1CK,CASCwP,IAkBUC,GAAgB,SAAAC,GAAU,OACrCP,IACC,kBAAM7B,GAAQ,uBADf6B,EAEC,SAAAxP,GAAK,OAAIkO,GAAQlO,KAFlBwP,CAGCO,IAkBUC,GAAoB,SAAAD,GAAU,OACzCP,IACC,kBAAMvC,GAAWlB,IAAG,WAAQ,KAAM,yBADnCyD,EAEC,SAAAxP,GAAK,OAAIiN,GAAWlB,IAAG,kBAAM/L,OAF9BwP,CAGCO,IAkBUE,GAAqB,SAAAF,GAAU,OAC1CP,IACC,kBAAMpD,GAAYL,IAAG,SAAAQ,GAAM,OAAI,SAAAmB,GAAC,OAAInB,EAAO,2BAD5CiD,EAEC,SAAAxP,GAAK,OAAIoM,GAAYL,IAAG,SAAA2B,GAAC,OAAI,SAAAlB,GAAO,OAAIA,EAAQxM,SAFjDwP,CAGCO,I","sources":["webpack://L/webpack/universalModuleDefinition","webpack://L/webpack/bootstrap","webpack://L/webpack/runtime/define property getters","webpack://L/webpack/runtime/hasOwnProperty shorthand","webpack://L/webpack/runtime/make namespace object","webpack://L/./src/arity.js","webpack://L/./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://L/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://L/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://L/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://L/./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://L/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://L/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://L/./src/conditional.js","webpack://L/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://L/./src/core.js","webpack://L/./src/utils.js","webpack://L/./src/string.js","webpack://L/./src/list.js","webpack://L/./src/Case.js","webpack://L/./src/AsyncEffect.js","webpack://L/./src/SyncEffect.js","webpack://L/./src/Either.js","webpack://L/./src/Maybe.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"L\"] = factory();\n\telse\n\t\troot[\"L\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * nary curried function and allows it to be called both as curried and n-ary.\n *\n * @HindleyMilner nary :: (a -> b) -> a -> b\n *\n * @pure\n * @param {function} fn\n * @return {function}\n *\n * @example\n * import {nary} from '@7urtle/lambda';\n *\n * const fn = nary(a => b => a + b);\n * fn('a')('b') === fn('a', 'b'); // => true\n */\nexport const nary = fn =>\n    (...args) => args.length === 0\n        ? fn()\n        : args.reduce(\n            (accumulator, current) => accumulator(current),\n            fn\n        );\n\n/**\n * curry takes n-ary function and allows it to be called both as curried and n-ary.\n *\n * @HindleyMilner curry :: (a -> b) -> a -> b\n *\n * @pure\n * @param {function} fn\n * @return {function}\n *\n * @example\n * import {curry} from '@7urtle/lambda';\n *\n * const fn = curry((a, b) => a + b);\n * fn('a')('b') === fn('a', 'b'); // => true\n */\nexport const curry = fn =>\n    (...args) => args.length >= fn.length\n        ? fn(...args)\n        : (...args2) => curry(fn)(...args, ...args2);","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import { typeOf, lengthOf, deepInspect } from \"./utils.js\";\nimport { everyOf, someOf } from './list.js';\nimport { nary } from \"./arity.js\";\n\n/**\n * and is a boolean-type function composition\n * where each boolean function is '&&'d together.\n * \n * The boolean functions may be entered in any order.\n * \n * and can be used together with or to encapsulate a predicate in a single function.\n * \n * @HindleyMilner and :: [(a -> boolean)] -> a -> boolean\n * \n * @pure\n * @param {function} predicates\n * @param {*} anything\n * @return {*}\n * \n * @example\n * import {and, isGreaterThan, isLessThan} from '@7urtle/lambda';\n * \n * const isEven = number => number % 2 === 0;\n * \n * const isSingleEvenDigit = and(isEven, isGreaterThan(-10), isLessThan(10));\n * isSingleEvenDigit(8)\n * // => true\n */\n export const and = (...predicates) => anything => everyOf(predicate => predicate(anything))(predicates);\n\n /**\n  * or is a boolean-type function composition\n  * where each boolean function is '||'d together.\n  * \n  * The boolean functions may be entered in any order.\n  * \n  * or can be used together with and to encapsulate a predicate in a single function.\n  * \n  * @HindleyMilner or :: [(a -> boolean)] -> a -> boolean\n  * \n  * @pure\n  * @param {function} predicates\n  * @param {*} anything\n  * @return {*}\n  * \n  * @example\n  * import {or} from '@7urtle/lambda';\n  * \n  * const isDivisibleBy = divisor => number => number % divisor === 0;\n  * const isFizzBuzzNumber = or(isDivisibleBy(3), isDivisibleBy(5));\n  * \n  * isFizzBuzzNumber(15)\n  * // => true\n  */\n export const or = (...predicates) => anything => someOf(predicate => predicate(anything))(predicates);\n\n/**\n * isEqual output is true if strict equality between a and b is true. isEqual output is always false for comparison\n * of objects and arrays.\n *\n * isEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isEqual} from '@7urtle/lambda';\n *\n * isEqual('something')('something'); // => true\n * isEqual('something')('something else'); // => false\n * isEqual(['a'])(['a']); // => false\n * isEqual({a : 'something'})({a : 'something'}); // => false\n * isEqual([])([]); // => false\n * isEqual([])([]); // => false\n *\n * // isEqual can be called both as a curried unary function or as a standard binary function\n * isEqual('something')('something') === isEqual('something', 'something');\n */\nexport const isEqual = nary(a => b => a === b);\n\n/**\n * isNotEqual output is true if strict equality between a and b is false. isNotEqual output is always true for\n * comparison of objects and arrays.\n *\n * isEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotEqual} from '@7urtle/lambda';\n *\n * isNotEqual('something')('something'); // => false\n * isNotEqual('something')('something else'); // => true\n * isNotEqual(['a'])(['a']); // => true\n * isNotEqual({a : 'something'})({a : 'something'}); // => true\n * isNotEqual([])([]); // => true\n * isNotEqual([])([]); // => true\n *\n * // isNotEqual can be called both as a curried unary function or as a standard binary function\n * isNotEqual('something')('something else') === isNotEqual('something', 'something else');\n */\nexport const isNotEqual = nary(a => b => a !== b);\n\n/**\n * isDeepEqual output is true if strict equality between the string conversion of a and the string conversion of b\n * is true including arrays and objects.\n *\n * isDeepEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isDeepEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isDeepEqual} from '@7urtle/lambda';\n *\n * isDeepEqual('something')('something'); // => true\n * isDeepEqual('something')('something else'); // => false\n * isDeepEqual(['a'])(['a']); // => true\n * isDeepEqual({a : 'something'})({a : 'something'}); // => true\n * isDeepEqual([])([]); // => true\n * isDeepEqual([])([]); // => true\n *\n * // isDeepEqual can be called both as a curried unary function or as a standard binary function\n * isDeepEqual('something')('something') === isDeepEqual('something', 'something');\n */\nexport const isDeepEqual = nary(a => b => isEqual(deepInspect(a))(deepInspect(b)));\n\n/**\n * isNotDeepEqual output is true if strict equality between the string conversion of a and the string conversion of b\n * is false including arrays and objects.\n *\n * isNotDeepEqual can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotDeepEqual :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotDeepEqual} from '@7urtle/lambda';\n *\n * isNotDeepEqual('something')('something'); // => false\n * isNotDeepEqual('something')('something else'); // => true\n * isNotDeepEqual(['a', 'b'])(['a']); // => true\n * isNotDeepEqual({a : 'something', b: c => c})({a : 'something'}); // => true\n * isNotDeepEqual([])([]); // => false\n * isNotDeepEqual([])([]); // => false\n *\n * // isNotDeepEqual can be called both as a curried unary function or as a standard binary function\n * isNotDeepEqual('something')('something else') === isNotDeepEqual('something', 'something else');\n */\nexport const isNotDeepEqual = nary(a => b => isNotEqual(deepInspect(a))(deepInspect(b)));\n\n/**\n * isTrue output is true if input is true.\n *\n * @HindleyMilner isTrue :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isTrue} from '@7urtle/lambda';\n *\n * isTrue(true); // => true\n * isTrue(false); // => false\n */\nexport const isTrue = isEqual(true);\n\n/**\n * isFalse output is true if input is false.\n *\n * @HindleyMilner isFalse :: a -> Boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isFalse} from '@7urtle/lambda';\n *\n * isFalse(true); // => false\n * isFalse(false); // => true\n */\nexport const isFalse = isEqual(false);\n\n/**\n * isGreaterThan output is true if b is greater than a.\n *\n * isGreaterThan can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isGreaterThan :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isGreaterThan} from '@7urtle/lambda';\n *\n * isGreaterThan(1)(2); // => true\n * isGreaterThan(3)(2); // => false\n *\n * // isGreaterThan can be called both as a curried unary function or as a standard binary function\n * isGreaterThan(1)(2) === isGreaterThan(1, 2);\n */\nexport const isGreaterThan = nary(a => b => b > a);\n\n/**\n * isLessThan output is true if b is less than a.\n *\n * isLessThan can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isLessThan :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isLessThan} from '@7urtle/lambda';\n *\n * isLessThan(1)(2); // => false\n * isLessThan(3)(2); // => true\n *\n * // isLessThan can be called both as a curried unary function or as a standard binary function\n * isLessThan(3)(2) === isLessThan(3, 2);\n */\nexport const isLessThan = nary(a => b => b < a);\n\n/**\n * isAtLeast output is true if b is greater or equal to a.\n *\n * isAtLeast can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isAtLeast :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isAtLeast} from '@7urtle/lambda';\n *\n * isAtLeast(1)(2); // => true\n * isAtLeast(2)(2); // => true\n * isAtLeast(3)(2); // => false\n *\n * // isAtLeast can be called both as a curried unary function or as a standard binary function\n * isAtLeast(1)(2) === isAtLeast(1, 2);\n */\nexport const isAtLeast = nary(a => b => b >= a);\n\n/**\n * isAtMost output is true if b is less or equal to a.\n *\n * isAtMost can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isAtMost :: a -> b -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isAtMost} from '@7urtle/lambda';\n *\n * isAtMost(1)(2); // => false\n * isAtMost(2)(2); // => true\n * isAtMost(3)(2); // => true\n *\n * // isAtLeast can be called both as a curried unary function or as a standard binary function\n * isAtMost(3)(2) === isAtMost(31, 2);\n */\nexport const isAtMost = nary(a => b => b <= a);\n\n/**\n * isBetween output is true if c is between a and b.\n *\n * isBetween can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner isBetween :: a -> b -> c -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {boolean}\n *\n * @example\n * import {isBetween} from '@7urtle/lambda';\n *\n * isBetween(1)(3)(2); // => true\n * isBetween(3)(1)(2); // => true\n * isBetween(1)(3)(3); // => false\n * isBetween(1)(3)(4); // => false\n *\n * // isBetween can be called both as a curried unary function or as a standard ternary function\n * isBetween(1)(3)(2) === isBetween(1, 3, 2);\n */\nexport const isBetween = nary(a => b => c =>\n    a > b\n    ? a > c && b < c\n    : a < c && b > c\n);\n\n/**\n * isInRange output is true if c is in range of a and b.\n *\n * isInRange can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner isInRange :: a -> b -> c -> boolean\n *\n * @pure\n * @param {number} a\n * @param {number} b\n * @param {number} c\n * @return {boolean}\n *\n * @example\n * import {isInRange} from '@7urtle/lambda';\n *\n * isInRange(1)(3)(2); // => true\n * isInRange(3)(1)(2); // => true\n * isInRange(1)(3)(3); // => true\n * isInRange(1)(3)(4); // => false\n *\n * // isInRange can be called both as a curried unary function or as a standard ternary function\n * isInRange(1)(3)(2) === isInRange(1, 3, 2);\n */\n export const isInRange = nary(a => b => c =>\n    a > b\n    ? a >= c && b <= c\n    : a <= c && b >= c\n);\n\n/**\n * isTypeOf output is true if b is a type of a.\n *\n * isTypeOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isTypeOf :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isTypeOf} from '@7urtle/lambda';\n *\n * isTypeOf('number')(1); // => true\n * isTypeOf('string')(1); // => false\n *\n * // isTypeOf can be called both as a curried unary function or as a standard binary function\n * isTypeOf('number')(1) === isTypeOf('number', 1);\n */\nexport const isTypeOf = nary(a => b => isEqual(typeOf(b))(a));\n\n/**\n * isNotTypeOf output is true if b is not a type of a.\n *\n * isNotTypeOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner isNotTypeOf :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {boolean}\n *\n * @example\n * import {isNotTypeOf} from '@7urtle/lambda';\n *\n * isNotTypeOf('number')(1); // => false\n * isNotTypeOf('string')(1); // => true\n *\n * // isNotTypeOf can be called both as a curried unary function or as a standard binary function\n * isNotTypeOf('string')(1) === isNotTypeOf('string', 1);\n */\nexport const isNotTypeOf = nary(a => b => isNotEqual(typeOf(b))(a));\n\n/**\n * isString output is true if input is a string.\n *\n * @HindleyMilner isString :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isString} from '@7urtle/lambda';\n *\n * isString('string'); // => true\n * isString(1); // => false\n */\nexport const isString = isTypeOf('string');\n\n/**\n * isNotString output is true if input is not a string.\n *\n * @HindleyMilner isNotString :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotString} from '@7urtle/lambda';\n *\n * isNotString('string'); // => false\n * isNotString(1); // => true\n */\nexport const isNotString = isNotTypeOf('string');\n\n/**\n * isBoolean output is true if input is a boolean.\n *\n * @HindleyMilner isBoolean :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isBoolean} from '@7urtle/lambda';\n *\n * isBoolean(false); // => true\n * isBoolean(1); // => false\n */\nexport const isBoolean = isTypeOf('boolean');\n\n/**\n * isNotBoolean output is true if input is not a boolean.\n *\n * @HindleyMilner isNotBoolean :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotBoolean} from '@7urtle/lambda';\n *\n * isNotBoolean(false); // => false\n * isNotBoolean(1); // => true\n */\nexport const isNotBoolean = isNotTypeOf('boolean');\n\n/**\n * isNull output is true if input is a null.\n *\n * @HindleyMilner isNull :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNull} from '@7urtle/lambda';\n *\n * isNull(null); // => true\n * isNull(1); // => false\n */\nexport const isNull = isEqual(null);\n\n/**\n * isNotNull output is true if input is not a null.\n *\n * @HindleyMilner isNotNull :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotNull} from '@7urtle/lambda';\n *\n * isNotNull(null); // => false\n * isNotNull(1); // => true\n */\nexport const isNotNull = isNotEqual(null);\n\n/**\n * isUndefined output is true if input is an undefined.\n *\n * @HindleyMilner isUndefined :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isUndefined} from '@7urtle/lambda';\n *\n * isUndefined(undefined); // => true\n * isUndefined(1); // => false\n */\nexport const isUndefined = isTypeOf('undefined');\n\n/**\n * isNotUndefined output is true if input is not an undefined.\n *\n * @HindleyMilner isNotUndefined :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotUndefined} from '@7urtle/lambda';\n *\n * isNotUndefined(undefined); // => false\n * isNotUndefined(1); // => true\n */\nexport const isNotUndefined = isNotTypeOf('undefined');\n\n/**\n * isNumber output is true if input is a number.\n *\n * @HindleyMilner isNumber :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNumber} from '@7urtle/lambda';\n *\n * isNumber(1); // => true\n * isNumber('string'); // => false\n */\nexport const isNumber = isTypeOf('number');\n\n/**\n * isNotNumber output is true if input is not a number.\n *\n * @HindleyMilner isNotNumber :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotNumber} from '@7urtle/lambda';\n *\n * isNotNumber(1); // => false\n * isNotNumber('string'); // => true\n */\nexport const isNotNumber = isNotTypeOf('number');\n\n/**\n * isObject output is true if b is an object, array, or null.\n *\n * @HindleyMilner isObject :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isObject} from '@7urtle/lambda';\n *\n * isObject({}); // => true\n * isObject([]); // => true\n * isObject(null); // => true\n * isObject(1); // => false\n */\nexport const isObject = isTypeOf('object');\n\n/**\n * isNotObject output is true if input is not an object, array, or null.\n *\n * @HindleyMilner isNotObject :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotObject} from '@7urtle/lambda';\n *\n * isNotObject({}); // => false\n * isNotObject([]); // => false\n * isNotObject(null); // => false\n * isNotObject(1); // => true\n */\nexport const isNotObject = isNotTypeOf('object');\n\n/**\n * isArray output is true if input is an array.\n *\n * @HindleyMilner isArray :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isArray} from '@7urtle/lambda';\n *\n * isArray([]); // => true\n * isArray({}); // => false\n */\nexport const isArray = Array.isArray;\n\n/**\n * isNotArray output is true if input is not an array.\n *\n * @HindleyMilner isNotArray :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotArray} from '@7urtle/lambda';\n *\n * isNotArray([]); // => false\n * isNotArray({}); // => true\n */\nexport const isNotArray = a => !Array.isArray(a);\n\n/**\n * isFunction output is true if input is a function.\n *\n * @HindleyMilner isFunction :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isFunction} from '@7urtle/lambda';\n *\n * isFunction(() => null); // => true\n * isFunction(1); // => false\n */\nexport const isFunction = isTypeOf('function');\n\n/**\n * isNotFunction output is true if input is not a function.\n *\n * @HindleyMilner isNotFunction :: a -> boolean\n *\n * @pure\n * @param {*} a\n * @return {boolean}\n *\n * @example\n * import {isNotFunction} from '@7urtle/lambda';\n *\n * isNotFunction(() => null); // => false\n * isNotFunction(1); // => true\n */\nexport const isNotFunction = isNotTypeOf('function');\n\n/**\n * isLength output is true if b is a length of a.\n *\n * @HindleyMilner isLength :: (string|array) -> b -> boolean\n *\n * @pure\n * @param {string|array} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isLength} from '@7urtle/lambda';\n *\n * isLength(3)('abc'); // => true\n * isLength(3)([1,2,3]); // => true\n * isLength(3)('abc'); // => false\n */\nexport const isLength = nary(a => b => isEqual(lengthOf(b))(a));\n\n/**\n * isNotLength output is true if b is not a length of a.\n * \n * The function can be called both as a unary isNotLength(a)(b) and binary isNotLength(a, b).\n *\n * @HindleyMilner isNotLength :: (string|array) -> b -> boolean\n *\n * @pure\n * @param {string|array} a\n * @param {number} b\n * @return {boolean}\n *\n * @example\n * import {isNotLength} from '@7urtle/lambda';\n *\n * isNotLength(3)('abc'); // => false\n * isNotLength(3)([1,2,3]); // => false\n * isNotLength(3)('abce'); // => true\n * \n * isNotLength(3)('abcd') === isNotLength(3, 'abcd'); // => true\n */\nexport const isNotLength = nary(a => b => !isLength(a)(b));\n\n/**\n * isElement output is true if input is an HTML or SVG Element. Otherwise it is false.\n *\n * @HindleyMilner isElement :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isElement} from '@7urtle/lambda';\n *\n * isElement(document.createElement('span')); // => true\n */\nexport const isElement = anything =>\n    (typeof Element !== 'undefined' && anything instanceof Element) ||\n    (typeof HTMLDocument !== 'undefined' && anything instanceof HTMLDocument);\n\n/**\n * isNotElement output is true if input is not an HTML or SVG Element. Otherwise it is false.\n *\n * @HindleyMilner isNotElement :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {isNotElement} from '@7urtle/lambda';\n *\n * isNotElement(document.createElement('span')); // => false\n */\nexport const isNotElement = anything => !isElement(anything);\n\n/**\n * isEmpty output is true if input is an empty string, array, or object. Otherwise it is false.\n *\n * @HindleyMilner isEmpty :: (string|array|Element) -> boolean\n *\n * @pure\n * @param {string|array|object} anything\n * @return {boolean}\n *\n * @example\n * import {isEmpty} from '@7urtle/lambda';\n *\n * isEmpty(''); // => true\n * isEmpty([]); // => true\n * isEmpty({}); // => true\n * isEmpty('abc'); // => false\n * isEmpty(document.getElementByID('image')); // => false\n */\nexport const isEmpty = anything =>\n    isLength(0)(anything) ||\n    isNotElement(anything) &&\n    (isObject(anything) ? isLength(0)(Object.getOwnPropertyNames(anything)) : false);\n\n/**\n * isNotEmpty output is false if input is an empty string, array, or object. Otherwise it is true.\n *\n * @HindleyMilner isNotEmpty :: (string|array|Element) -> boolean\n *\n * @pure\n * @param {string|array|object} anything\n * @return {boolean}\n *\n * @example\n * import {isNotEmpty} from '@7urtle/lambda';\n *\n * isNotEmpty(''); // => false\n * isNotEmpty([]); // => false\n * isNotEmpty('abc'); // => true\n * isNotEmpty({}); => true\n * isNotEmpty(document.getElementByID('image')); // => true\n */\nexport const isNotEmpty = anything => !isEmpty(anything);\n\n/**\n * isZero output is true if input is 0.\n *\n * @HindleyMilner isZero :: a -> boolean\n *\n * @pure\n * @param {number} a\n * @return {boolean}\n *\n * @example\n * import {isZero} from '@7urtle/lambda';\n *\n * isZero(0); // => true\n * isZero(1); // => false\n */\nexport const isZero = isEqual(0);\n\n/**\n * isNotZero output is true if input is not 0.\n *\n * @HindleyMilner isNotZero :: a -> boolean\n *\n * @pure\n * @param {number} a\n * @return {boolean}\n *\n * @example\n * import {isZero} from '@7urtle/lambda';\n *\n * isZero(0); // => false\n * isZero(1); // => true\n */\nexport const isNotZero = isNotEqual(0);\n\n/**\n * isNothing returns true if input is null, undefined or empty string or empty array or empty object or the monad Nothing.\n *\n * @HindleyMilner isNothing :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import { isNothing, Maybe, Just, Nothing } from '@7urtle/lambda';\n *\n * isNothing(null); // => true\n * isNothing(undefined); // => true\n * isNothing(''); // => true\n * isNothing([]); // => true\n * isNothing({}); // => true\n * isNothing(Maybe.of('')); // => true\n * isNothing(Nothing); // => true\n * isNothing('7urtle'); // => false\n * isNothing(Maybe.of('7urtle')); // => false\n * isNothing(Just('7urtle')); // => false\n */\nexport const isNothing = anything =>\n    anything && anything.isNothing\n    ? anything.isNothing()\n    : isNull(anything) || isUndefined(anything) || isEmpty(anything);\n\n/**\n * isJust returns true if input is not null, undefined or empty string or empty array or empty object.\n *\n * @HindleyMilner isJust :: a -> boolean\n *\n * @pure\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import { isJust, Maybe, Just, Nothing } from '@7urtle/lambda';\n *\n * isJust(null); // => false\n * isJust(undefined); // => false\n * isJust(''); // => false\n * isJust([]); // => false\n * isJust({}); // => false\n * isJust(Nothing); // => false\n * isJust('7urtle'); // => true\n * isJust(Maybe.of('7urtle')); // => true\n * isJust(Just('7urtle')); // => true\n */\nexport const isJust = anything =>\n    !isNothing(anything);\n\n/**\n * when tests anything argument by passing it to predicate function. If the predicate function is true, when\n * will return the result of whenTrueFn function which receivs the same anything argument. If the predicate\n * is false, then the anything argument is returned unchanged.\n * \n * The function can be called both as a unary when(predicate)(whenTrueFn)(anything) and ternary when(predicate, whenTrueFn, anything).\n *\n * @HindleyMilner when :: (a -> Boolean) -> (a -> a) -> a -> a\n *\n * @pure\n * @param {function} predicate\n * @param {function} whenTrueFn\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {when} from '@7urtle/lambda';\n *\n * const predicate = a => a > 1;\n * const whenTrueFn = a => a * 2;\n * \n * when(predicate)(whenTrueFn)(2); // => 4\n * when(predicate)(whenTrueFn)(1); // => 1\n * \n * when(predicate)(whenTrueFn)(2) === when(predicate, whenTrueFn, 2); // => true\n */\nexport const when = nary(predicate => whenTrueFn => anything =>\n    predicate(anything)\n    ? whenTrueFn(anything)\n    : anything\n);\n\n/**\n * unless tests anything argument by passing it to predicate function. If the predicate function is false, unless\n * will return the result of whenFalseFn function which receivs the same anything argument. If the predicate\n * is true, then the anything argument is returned unchanged.\n * \n * The function can be called both as a unary unless(predicate)(whenFalseFn)(anything) and ternary unless(predicate, whenFalseFn, anything).\n *\n * @HindleyMilner unless :: (a -> Boolean) -> (a -> a) -> a -> a\n *\n * @pure\n * @param {function} predicate\n * @param {function} whenFalseFn\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {unless} from '@7urtle/lambda';\n *\n * const predicate = a => a > 1;\n * const whenFalseFn = a => a * 2;\n * \n * when(predicate)(whenFalseFn)(4); // => 4\n * when(predicate)(whenFalseFn)(1); // => 2\n * \n * when(predicate)(whenFalseFn)(1) === when(predicate, whenFalseFn, 1); // => true\n */\nexport const unless = nary(predicate => whenFalseFn => anything =>\n    predicate(anything)\n    ? anything\n    : whenFalseFn(anything)\n);\n\n/**\n * ifElse tests anything argument by passing it to predicate function. If the predicate function is true, ifElse\n * will return the result of whenTrueFn function which receivs the same anything argument. If the predicate\n * is false, then the anything argument is passed to the whenFalseFn function.\n * \n * The function can be called both as a unary ifElse(predicate)(whenTrueFn)(whenFalseFn)(anything) and quaternary\n * ifElse(predicate, whenTrueFn, whenFalseFn, anything).\n *\n * @HindleyMilner ifElse :: (a -> Boolean) -> (a -> a) -> (a -> a) a -> a\n *\n * @pure\n * @param {function} predicate\n * @param {function} whenTrueFn\n * @param {function} whenFalseFn\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {ifElse} from '@7urtle/lambda';\n *\n * const predicate = a => a > 1;\n * const whenTrueFn = a => a / 2;\n * const whenFalseFn = a => a * 2;\n * \n * ifElse(predicate)(whenTrueFn)(whenFalseFn)(4); // => 2\n * ifElse(predicate)(whenTrueFn)(whenFalseFn)(1); // => 2\n * \n * ifElse(predicate)(whenTrueFn)(whenFalseFn)(1) === ifElse(predicate, whenTrueFn, whenFalseFn, 1); // => true\n */\n export const ifElse = nary(predicate => whenTrueFn => whenFalseFn => anything =>\n    predicate(anything)\n    ? whenTrueFn(anything)\n    : whenFalseFn(anything)\n);","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import { reduce, reduceRight } from './list.js';\nimport { isString, isArray, isObject } from './conditional.js';\nimport { minusOneToUndefined, passThrough } from './utils.js';\nimport { nary } from \"./arity.js\";\n\n/**\n * identity is a function that simply passes its input to its output without changing it.\n *\n * @HindleyMilner identity :: a -> a\n *\n * @pure\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {identity} from '@7urtle/lambda';\n *\n * identity('anything');\n * // => anything\n */\nexport const identity = anything => anything;\n\n/**\n * compose is a right-to-left function composition\n * where each function receives input and hands over its output to the next function.\n *\n * compose executes functions in reverse order to pipe.\n *\n * compose(f,g)(x) is equivalent to f(g(x)).\n *\n * @HindleyMilner compose :: [(a -> b)] -> a -> b\n *\n * @pure\n * @param {function} fns\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {compose} from '@7urtle/lambda';\n *\n * const addA = a => a + 'A';\n * const addB = a => a + 'B';\n * const addAB = value => compose(addA, addB)(value);\n *\n * addAB('Order: ');\n * // => Order: BA\n */\nexport const compose = (...fns) => anything => reduceRight(anything)((v, f) => f(v))(fns);\n\n/**\n * pipe output is a left-to-right function composition\n * where each function receives input and hands over its output to the next function.\n *\n * pipe executes functions in reverse order to compose.\n *\n * pipe(f,g)(x) is equivalent to g(f(x)).\n *\n * @HindleyMilner pipe :: [(a -> b)] -> a -> b\n *\n * @pure\n * @param {function} fns\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {pipe} from '@7urtle/lambda';\n *\n * const addA = a => a + 'A';\n * const addB = a => a + 'B';\n * const addAB = value => pipe(addA, addB)(value);\n *\n * addAB('Order: ');\n * // => Order: AB\n */\nexport const pipe = (...fns) => anything => reduce(anything)((v, f) => f(v))(fns);\n\n/**\n * map executes mapper function over input. If the input is array or monad, their map functions\n * are executed. If the input is anything else the mapper function is executed with the input\n * as its argument.\n *\n * In case of monads, you should use map when you want to work with functors using functions\n * and functional composition rather than calling Functor.map.\n *\n * If you need to both filter and map over an array, consider using the filterMap function.\n *\n * map can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner map :: (a -> b) -> a -> b\n *\n * @param {function} mapper\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {map, Maybe, upperCaseOf} from '@7urtle/lambda';\n *\n * const mapper = a => a + 'm';\n * const list = ['a', 'b', 'c'];\n *\n * // the function mapper is applied to each member of the array\n * map(mapper)(list); // => ['am', 'bm', 'cm']\n *\n * // the function upperCaseOf is applied to the value of the functor\n * map(upperCaseOf)(Maybe.of('something')); // => Just('SOMETHING')\n * \n * // the function upperCaseOf is applied to the input string\n * map(upperCaseOf)('turtle'); // => 'TURTLE'\n *\n * // use of map equals the use of map on the functor\n * map(upperCaseOf)(Maybe.of('something')).value === Maybe.of('something').map(upperCaseOf).value;\n *\n * // map can be called both as a curried unary function or as a standard binary function\n * map(upperCaseOf)(Maybe.of('something')).value === map(upperCaseOf, Maybe.of('something')).value;\n */\nexport const map = nary(mapper => anything =>\n    anything && anything.map\n    ? anything.map(mapper)\n    : mapper(anything)\n);\n\n/**\n * flatMap maps function over inputted functor outputting resulting flattened functor.\n *\n * You should use flatMap when you want to work with functors using functions\n * and functional composition rather than calling flatMaps.\n *\n * The function can be called both as a unary flatMap(fn)(functor) and binary flatMap(fn, functor).\n *\n * @HindleyMilner flatMap :: (a -> Functor) -> Functor -> Functor\n *\n * @param {function} fn\n * @param {functor} functor\n * @return {functor}\n *\n * @example\n * import {flatMap, map, Maybe} from '@7urtle/lambda';\n *\n * const maybePlus2 = number => Maybe.of(number + 2);\n *\n * // the function maybePlus2 is applied to the value of the functor\n * flatMap(maybePlus2)(Maybe.of(3)); // => Just(5)\n * map(maybePlus2)(Maybe.of(3)); // => Just(Just(5))\n *\n * // use of flatMap equals the use of flatMap on the functor\n * flatMap(maybePlus2)(Maybe.of(3)).value === Maybe.of(3).flatMap(maybePlus2).value;\n *\n * // flatMap can be called both as a curried unary function or as a standard binary function\n * flatMap(maybePlus2)(Maybe.of(3)).value === flatMap(maybePlus2, Maybe.of(3)).value;\n */\nexport const flatMap = nary(fn => functor => functor.flatMap(fn));\n\n/**\n * liftA2 provides point-free way of writing calls over applicative functors and functions expecting 2 inputs. It\n * applies input function over both functors values providing a resulting functor.\n *\n * The function can be called both as a unary liftA2(fn)(functor)(functor) and ternary liftA2(fn, functor, functor).\n *\n * @HindleyMilner liftA2 (a -> b -> c) -> Applicative a -> Applicative b -> Applicative c\n *\n * @pure\n * @param {function} fn\n * @param {functor} ap1\n * @param {functor} ap2\n * @return {functor}\n *\n * @example\n * import {liftA2, Maybe} from '@7urtle/lambda';\n *\n * const add = a => b => a + b;\n *\n * // function add which expects two inputs is applied to the values of two applicative functors Maybe\n * // the result is a Maybe functor with the internal value 5\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)); // => Just(5)\n *\n * // an example of applying a function over a Maybe of undefined value to demonstrate continued safety of functors\n * liftA2(add)(Maybe.of(1))(Maybe.of(undefined)).isNothing(); // => true\n *\n * // liftA2 can be called both as a curried unary function or as a standard ternary function\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)).value === liftA2(add, Maybe.of(2), Maybe.of(3)).value;\n */\nexport const liftA2 = nary(fn => ap1 => ap2 => ap1.map(fn).ap(ap2));\n\n/**\n * liftA3 provides point-free way of writing calls over applicative functors and functions expecting 3 inputs. It\n * applies input function over input functors values providing a resulting functor.\n *\n * The function can be called both as a unary liftA3(fn)(functor)(functor)(functor) and quaternary liftA2(fn, functor, functor, functor).\n *\n * @HindleyMilner liftA3 (a -> b -> c -> d) -> Applicative a -> Applicative b -> Applicative c -> Applicative d\n *\n * @pure\n * @param {function} fn\n * @param {functor} ap1\n * @param {functor} ap2\n * @param {functor} ap3\n * @return {functor}\n *\n * @example\n * import {liftA3, Maybe} from '@7urtle/lambda';\n *\n * const add = a => b => c => a + b + c;\n *\n * // function add which expects three inputs is applied to the values of three applicative functors Maybe\n * // the result is a Maybe functor with the internal value 9\n * liftA3(add)(Maybe.of(2))(Maybe.of(3))(Maybe.of(4)); // => Just(9)\n *\n * // an example of applying a function over a Maybe of undefined value to demonstrate continued safety of functors\n * liftA3(add)(Maybe.of(1))(Maybe.of(2))(Maybe.of(undefined)).isNothing(); // => true\n *\n * // liftA3 can be called both as a curried unary function or as a standard quaternary function\n * liftA3(add)(Maybe.of(2))(Maybe.of(3))(Maybe.of(4)).value === liftA3(add, Maybe.of(2), Maybe.of(3), Maybe.of(4)).value;\n */\nexport const liftA3 = nary(fn => ap1 => ap2 => ap3 => ap1.map(fn).ap(ap2).ap(ap3));\n\n/**\n * contact outputs concatenated inputs of strings, arrays and shallow objects or outputs undefined for other types.\n *\n * concat can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner concat :: a -> a|boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {concat} from '@7urtle/lambda';\n *\n * concat('cd')('ab'); // => 'abcd'\n * concat([3, 4])([1,2]); // => [1, 2, 3, 4]\n * concat({here: {here: 'there'}})({hi: 'hello'}); // => {hi: 'hello', here: {here: 'there'}}\n * concat('cd')(1); // => undefined\n *\n * // concat can be called both as a curried unary function or as a standard binary function\n * concat('cd')('ab') === concat('cd', 'ab');\n */\nexport const concat = nary(a => b =>\n    isString(b) || isArray(b)\n        ? b.concat(a)\n        : isObject(b)\n            ? { ...b, ...a }\n            : undefined);\n\n/**\n * merge performs a deep merge on all input objects and arrays.\n *\n * @HindleyMilner merge :: [a] -> [b]\n *\n * @pure\n * @param {array|object} sources\n * @return {array|object}\n *\n * @example\n * import {merge} from '@7urtle/lambda';\n *\n * const obj1 = { a: 'a', c: ['a'] };\n * const obj2 = { b: a => a, d: ['a', 'b'] };\n * const obj3 = { a: 'c', c: ['c'] };\n *\n * merge(obj1, obj2, obj3));\n * // => {\"a\": \"c\", \"b\": a => a, \"c\": [\"a\", \"c\"], \"d\": [\"a\", \"b\"]}\n *\n * const list1 = ['a', 'b'];\n * const list2 = [1, 2];\n *\n * merge(list1,list2);\n * // => ['a', 'b', 1, 2]\n * \n * merge(list1, obj1)\n * // => {\"0\": \"a\", \"1\": \"b\", \"a\": \"a\", \"c\": [\"a\"]}\n */\nexport const merge = (...sources) =>\n    reduce\n        ([])\n        ((acc, current) =>\n            isArray(current)\n                ? [...acc, ...current]\n                : isObject(current)\n                    ? reduce\n                        (acc)\n                        ((a, c) =>\n                            isObject(current[c]) && c in acc\n                                ? { ...a, [c]: merge(acc[c], current[c]) }\n                                : { ...a, [c]: current[c] }\n                        )\n                        (Object.getOwnPropertyNames(current))\n                    : { ...acc, ...current }\n        )\n        (sources);\n\n/**\n * includes(a)(b) output is true if b includes a.\n *\n * includes can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner includes :: a -> b -> boolean\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {includes} from '@7urtle/lambda';\n *\n * includes('rt')('7urtle'); // => true\n * includes(1)([1, 2, 3]) // => true\n * includes('turtle')([1, 2, 3]) // => false\n *\n * // includes can be called both as a curried unary function or as a standard binary function\n * includes('rt')('7urtle') === includes('rt', '7urtle');\n */\nexport const includes = nary(a => b => b.includes(a));\n\n/**\n * indexOf(a)(b) outputs position of input a within input b or undefined if it is not found.\n *\n * indexOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner indexOf :: a -> b -> number\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {indexOf} from '@7urtle/lambda';\n *\n * indexOf('7')('7urtle'); // => 0\n * indexOf(7)('7urtle'); // => 0\n * indexOf(2)([1, 2, 3]); // => 1\n * indexOf(4)([1, 2, 3]); // => undefined\n *\n * // indexOf can be called both as a curried unary function or as a standard binary function\n * indexOf('7')('7urtle') === indexOf('7', '7urtle');\n */\nexport const indexOf = nary(a => b => minusOneToUndefined(b.indexOf(a)));\n\n/**\n * lastIndexOf(a)(b) outputs position of input a withing input b looking from the end or it retuns undefined if it is not found.\n *\n * lastIndexOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner lastIndexOf :: a -> b -> number\n *\n * @pure\n * @param {*} a\n * @param {*} b\n * @return {*}\n *\n * @example\n * import {lastIndexOf} from '@7urtle/lambda';\n *\n * lastIndexOf('urtle')('7urtle'); // => 1\n * lastIndexOf(2)([1, 2, 3, 2]); // => 3\n * lastIndexOf('8')('7urtle'); // => undefined\n *\n * // lastIndexOf can be called both as a curried unary function or as a standard binary function\n * lastIndexOf('7')('7urtle') === lastIndexOf('7', '7urtle');\n */\nexport const lastIndexOf = nary(a => b => minusOneToUndefined(b.lastIndexOf(a)));\n\n/**\n * memoize uses input memory to save output of input function and then uses it to lookup the result on a repeated run. This\n * function is not pure because the input memory is modified in the process.\n *\n * The function can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner memoize :: object -> (a -> b) -> a -> b\n *\n * @param {object} memory\n * @param {function} fn\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {memoize} from '@7urtle/lambda';\n *\n * const addTwo = a => a + 2;\n * let memory = {};\n *\n * memoize(memory)(addTwo)(1); // => 3\n * memoize(memory)(addTwo)(1); // => 3\n * memory[1]; // => 3\n *\n * // lastIndexOf can be called both as a curried unary function or as a standard ternary function\n * memoize(memory)(addTwo)(1) === memoize(memory, addTwo, 1);\n */\nexport const memoize = nary(memory => fn => anything =>\n    anything in memory\n        ? memory[anything]\n        : passThrough(b => memory[anything] = b)(fn(anything))\n);\n\n/**\n * memo takes input function and returns it enhanced by memoization which ensures that each result is\n * always remembered internally and executed only once.\n *\n * @HindleyMilner memo :: (a -> b) -> (a -> b)\n *\n * @pure\n * @param {function} fn\n * @return {function}\n *\n * @example\n * import {memo} from '@7urtle/lambda';\n *\n * const addTwo = a => a + 2;\n * const memoAddTwo = memo(addTwo);\n * const memoAddThree = memo(a => a + 3);\n *\n * memoAddTwo(1); // => 3\n * memoAddThree(1); // => 4\n *\n * let count = 0;\n * const increaseCount = () => ++count;\n *\n * increaseCount(); // 1\n * increaseCount(); // 2\n *\n * const memoIncreaseCount = memo(increaseCount);\n *\n * memoIncreaseCount(); // 3\n * memoIncreaseCount(); // 3\n * memoIncreaseCount(); // 3\n */\nexport const memo = fn => memoize({})(fn);\n\n/**\n * fail throws the input error. It is just a function wrapped around JavaScript throw.\n *\n * @HindleyMilner fail :: a -> b -> number\n *\n * @impure\n * @param {string|Error} error\n * @return {null}\n *\n * @example\n * import { fail } from '@7urtle/lambda';\n *\n * fail('I am an error.'); // => throws 'I am an error.'\n * fail(new Error('something happend :(')); // => throws Error('something happened :('))\n */\nexport const fail = error => { throw error; };","import { isArray, isEqual, isString, isObject, isFunction, isNull, isUndefined } from \"./conditional.js\";\nimport {keysOf, join} from \"./list.js\";\nimport {map} from \"./core.js\";\nimport {nary} from \"./arity.js\";\n\n/**\n * typeOf outputs a type of its input.\n *\n * @HindleyMilner typeOf :: a -> string\n *\n * @pure\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {typeOf} from '@7urtle/lambda';\n *\n * typeOf('7turtle'); // => 'string'\n */\nexport const typeOf = a => typeof a;\n\n/**\n * lengthOf outputs the length of an input.\n *\n * @HindleyMilner lengthOf :: (string|array) -> number\n *\n * @pure\n * @param {string|array} a\n * @return {number}\n *\n * @example\n * import {lengthOf} from '@7urtle/lambda';\n *\n * lengthOf('7turtle'); // => 7\n * lengthOf([1,2,3]); // => 3\n * lengthOf({}); // => undefined\n */\nexport const lengthOf = a => a.length;\n\n/**\n * passThrough output is the same as input a. passThrough executes function passed as first argument.\n *\n * passThrough can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner passThrough :: function -> a -> a\n *\n * @pure\n * @param {function} fn\n * @param {*} anything\n * @return {boolean}\n *\n * @example\n * import {passThrough} from '@7urtle/lambda';\n *\n * passThrough(() => 'b')('a'); // => 'a'\n *\n * // isTypeOf can be called both as a curried unary function or as a standard binary function\n * passThrough(() => 'b')('a') === passThrough(() => 'b', 'a');\n */\nexport const passThrough = nary(fn => anything => {\n  fn(anything);\n  return anything;\n});\n\n/**\n * log output is the same as input and it logs the input value. log causes side effect of console.log.\n *\n * @HindleyMilner log :: a -> a\n *\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {log} from '@7urtle/lambda';\n *\n * log('anything'); // => 'anything'\n */\nexport const log = passThrough(console.log);\n\n/**\n * spy output is the same as input and it logs the deepInspect of the input. spy causes side effect of console.log.\n *\n * @HindleyMilner spy :: a -> a\n *\n * @param {*} anything\n * @return {*}\n *\n * @example\n * import {spy} from '@7urtle/lambda';\n *\n * spy([1, 'a']); // => \"[1, 'a']\"\n */\nexport const spy = passThrough(a => console.log(deepInspect(a)));\n\n/**\n * minusOneToUndefined output is the same as input or undefined if input is -1.\n *\n * Because some functions return -1 as error state, this function is created to change it into a more consistent\n * undefined output.\n *\n * @HindleyMilner minusOneToUndefined :: a -> a|boolean\n *\n * @pure\n * @param {*} anything\n * @return {*|boolean}\n *\n * @example\n * import {log} from '@7urtle/lambda';\n *\n * minusOneToUndefined(-1); // => undefined\n * minusOneToUndefined(0); // => 0\n * minusOneToUndefined('7urtle'); // => '7urtle'\n */\nexport const minusOneToUndefined = anything => isEqual(-1)(anything) ? undefined: anything;\n\n/**\n * inspectFunction outputs name of named function or its conversion to string.\n *\n * @HindleyMilner inspectFunction :: (a -> b) -> string\n *\n * @pure\n * @param {function} fn\n * @return {string}\n *\n * @example\n * import {inspectFunction} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * inspectFunction(namedFunction); // => 'namedFunction'\n * inspectFunction(() => 'b');\n * // => `function () {\n * // =>     return 'b';\n * // => }`\n */\nexport const inspectFunction = fn => fn.name ? fn.name : String(fn);\n\n/**\n * inspectArray maps over input array [a] and outputs string representing it.\n *\n * @HindleyMilner inspectArray :: [a] -> string\n *\n * @pure\n * @param {array} a\n * @return {string}\n *\n * @example\n * import {inspectArray} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * inspectArray([1, 'a']); // => \"[1, 'a']\"\n * inspectArray([namedFunction, 'a']); // => \"[namedFunction, 'a']\"\n */\nexport const inspectArray = a => `[${join(', ')(map(deepInspect)(a))}]`;\n\n/**\n * inspectString outputs string representing input.\n *\n * @HindleyMilner inspectString :: a -> string\n *\n * @pure\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {inspectString} from '@7urtle/lambda';\n *\n * inspectString('my string'); // => \"'my string'\"\n */\nexport const inspectString = a => `'${a}'`;\n\n/**\n * inspectObject outputs string representing input.\n *\n * @HindleyMilner inspectObject :: a -> string\n *\n * @pure\n * @param {object} a\n * @return {string}\n *\n * @example\n * import {inspectObject} from '@7urtle/lambda';\n *\n * inspectObject({a: 'b'}); // => \"{a: 'b'}\"\n */\nexport const inspectObject = a =>\n  isFunction(a.inspect)\n    ? a.inspect()\n    : `{${join(', ')(map(join(': '))(map(k => [k, deepInspect(a[k])])(keysOf(a))))}}`\n\n/**\n * deepInspect runs recursively over input and outputs string representing the input.\n *\n * @HindleyMilner deepInspect :: a -> string\n *\n * @pure\n * @param {*} a\n * @return {string}\n *\n * @example\n * import {deepInspect} from '@7urtle/lambda';\n *\n * function namedFunction() {\n *   return null;\n * }\n *\n * deepInspect({a: 'b'}); // => \"{a: 'b'}\"\n * deepInspect(namedFunction); // => 'namedFunction'\n * deepInspect([1, 'a']); // => \"[1, 'a']\"\n * deepInspect('my string'); // => \"'my string'\"\n * deepInspect(undefined); // => 'undefined'\n */\nexport const deepInspect = a =>\n  isUndefined(a)\n    ? 'undefined'\n    : isNull(a)\n      ? 'null'\n      : isFunction(a)\n        ? inspectFunction(a)\n        : isArray(a)\n          ? inspectArray(a)\n          : isObject(a)\n            ? inspectObject(a)\n            : isString(a)\n              ? inspectString(a)\n              : String(a);","import {minusOneToUndefined} from './utils.js';\nimport {nary} from \"./arity.js\";\n\n/**\n * trim output is a string without white characters around it.\n *\n * @HindleyMilner trim :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {trim} from '@7urtle/lambda';\n *\n * trim(' a \\n '); // => 'a'\n */\nexport const trim = string => string.trim();\n\n/**\n * testRegEx outputs true if string b passes regular expression a.\n *\n * testRegEx can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner testRegEx :: regex -> string -> boolean\n *\n * @pure\n * @param {regex} regex\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {testRegEx} from '@7urtle/lambda';\n *\n * testRegEx(/[a-z]/)('7urtle'); // => true\n * testRegEx(/[0-9]/)('1'); // => true\n * testRegEx(/[0-9]/)('abc'); // => false\n *\n * // testRegEx can be called both as a curried unary function or as a standard binary function\n * testRegEx(/[a-z]/)('7urtle') === testRegEx(/[a-z]/, '7urtle');\n */\nexport const testRegEx = nary(regex => string => regex.test(string));\n\n/**\n * substr outputs substring based on provided string, start and limit.\n *\n * substr can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner substr :: number -> number -> string -> string\n *\n * @pure\n * @param {number} limit\n * @param {number} start\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {substr} from '@7urtle/lambda';\n *\n * substr(3)(1)('7urtle'); // => 'urt'\n * substr(1)(0)('7urtle'); // => '7'\n * substr(1)(-1)('7urtle'); // => 'e'\n *\n * // substr can be called both as a curried unary function or as a standard ternary function\n * substr(3)(1)('7urtle') === substr(3, 1, '7urtle');\n */\nexport const substr = nary(limit => start => string => string.substr(start, limit));\n\n/**\n * firstLetterOf outputs the first letter of a provided string.\n *\n * @HindleyMilner firstLetterOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {firstLetterOf} from '@7urtle/lambda';\n *\n * firstLetterOf('7urtle'); // => '7'\n */\nexport const firstLetterOf = string => string.substr(0, 1);\n\n/**\n * lastLetterOf outputs the last letter of a provided string.\n *\n * @HindleyMilner lastLetterOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {lastLetterOf} from '@7urtle/lambda';\n *\n * lastLetterOf('7urtle'); // => 'e'\n */\nexport const lastLetterOf = string => string.substr(-1, 1);\n\n/**\n * startsWith outputs true if an input string starts with provided string.\n *\n * startsWith can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner startsWith :: string -> string -> boolean\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {startsWith} from '@7urtle/lambda';\n *\n * startsWith('7')('7urtle'); // => true\n * startsWith('7urtl')('7urtle'); // => true\n * startsWith('8urtl')('7urtle'); // => false\n *\n * // startsWith can be called both as a curried unary function or as a standard binary function\n * startsWith('7')('7urtle') === startsWith('7', '7urtle');\n */\nexport const startsWith = nary(substring => string => string.startsWith(substring));\n\n/**\n * endsWith outputs true if an input string ends with provided string.\n *\n * endsWith can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner endsWith :: string -> string -> boolean\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {boolean}\n *\n * @example\n * import {endsWith} from '@7urtle/lambda';\n *\n * endsWith('7e')('7urtle'); // => true\n * endsWith('urtle')('7urtle'); // => true\n * endsWith('urtls')('7urtle'); // => false\n *\n * // endsWith can be called both as a curried unary function or as a standard binary function\n * endsWith('e')('7urtle') === endsWith('e', '7urtle');\n */\nexport const endsWith = nary(substring => string => string.endsWith(substring));\n\n/**\n * repeat outputs new string repeating input string inputted count of times.\n *\n * repeat can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner repeat :: number -> string -> string\n *\n * @pure\n * @param {number} count\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {repeat} from '@7urtle/lambda';\n *\n * repeat(2)('7urtle'); // => '7urtle7urtle'\n * repeat(0)('7urtle'); // => ''\n *\n * // repeat can be called both as a curried unary function or as a standard binary function\n * repeat(2)('7urtle') === repeat(2, '7urtle');\n */\nexport const repeat = nary(count => string => string.repeat(count));\n\n/**\n * replace outputs new string replacing input substring with input replacement string in input string.\n *\n * replace can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner replace :: string -> string -> string -> string\n *\n * @pure\n * @param {string} replacement\n * @param {string} substring\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {replace} from '@7urtle/lambda';\n *\n * replace('8')('7')('7urtle'); // => '8urtle'\n * replace('7')('')('7urtle'); // => '77urtle'\n * replace('')('7')('7urtle'); // => 'urtle'\n *\n * // replace can be called both as a curried unary function or as a standard ternary function\n * replace('8')('7')('7urtle') === replace('8', '7', '7urtle');\n */\nexport const replace = nary(replacement => substring => string => string.replace(substring, replacement));\n\n/**\n * search outputs position of input substring or regular expression withing input string or undefined if it is not found.\n *\n * search can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner search :: string/regex -> string -> number\n *\n * @pure\n * @param {string|regex} substring\n * @param {string} string\n * @return {number}\n *\n * @example\n * import {search} from '@7urtle/lambda';\n *\n * search('7')('7urtle'); 0\n * search('e')('7urtle'); // => 5\n * search('rt')('7urtle'); // => 2\n * search(/URT/i)('7urtle'); // => 1\n * search('8')('7urtle'); => undefined\n *\n * // search can be called both as a curried unary function or as a standard binary function\n * search('7')('7urtle') === search('7', '7urtle');\n */\nexport const search = nary(substring => string => minusOneToUndefined(string.search(substring)));\n\n/**\n * split outputs and array of an input string split by the input substring.\n *\n * split can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner split :: string -> string -> array\n *\n * @pure\n * @param {string} substring\n * @param {string} string\n * @return {array}\n *\n * @example\n * import {split} from '@7urtle/lambda';\n *\n * split(' ')('7urtles are awesome'); // => ['7urtles', 'are', 'awesome']\n * split('/')('7urtles are awesome'); // => ['7urtles are awesome']\n *\n * // split can be called both as a curried unary function or as a standard binary function\n * split(' ')('7urtles are awesome') === split(' ', '7urtles are awesome');\n */\nexport const split = nary(substring => string => string.split(substring));\n\n/**\n * lowerCaseOf outputs the lower case version of input string.\n *\n * @HindleyMilner lowerCaseOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {lowerCaseOf} from '@7urtle/lambda';\n *\n * lowerCaseOf('PeTrA'); // => 'petra'\n * lowerCaseOf('PŘÍŠERNĚ ŽLUŤOUČKÝ KŮŇ ÚPĚL ĎÁBELSKÉ ÓDY'); // => 'příšerně žluťoučký kůň úpěl ďábelské ódy'\n */\nexport const lowerCaseOf = string => string.toLowerCase();\n\n/**\n * upperCaseOf outputs the upper case version of input string.\n *\n * @HindleyMilner upperCaseOf :: string -> string\n *\n * @pure\n * @param {string} string\n * @return {string}\n *\n * @example\n * import {upperCaseOf} from '@7urtle/lambda';\n *\n * upperCaseOf('PeTrA'); // => 'PETRA'\n * upperCaseOf('příšerně žluťoučký kůň úpěl ďábelské ódy'); // => 'PŘÍŠERNĚ ŽLUŤOUČKÝ KŮŇ ÚPĚL ĎÁBELSKÉ ÓDY'\n */\nexport const upperCaseOf = string => string.toUpperCase();","import {lengthOf, minusOneToUndefined} from './utils.js';\nimport {nary} from \"./arity.js\";\nimport {upperCaseOf} from \"./string.js\";\n\n/**\n * reduce executes input reducer function that over each member of input array [b] to output a single value. It is\n * the preferred way of working functionally with arrays as it is a pure function that does not cause mutations.\n *\n * reduce executes functions in reverse order to reduceRight.\n *\n * reduce can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner reduce :: a -> ((a, b) -> a) -> [b] -> a\n *\n * @pure\n * @param {*} initial\n * @param {function} reducer\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {reduce} from '@7urtle/lambda';\n *\n * const reducer = (accumulator, currentValue) => accumulator + currentValue;\n * const list = ['a', 'b', 'c'];\n *\n * reduce('start')(reducer)(list); // => startabc\n *\n * // reduce can be called both as a curried unary function or as a standard ternary function\n * reduce('start')(reducer)(list) === reduce('start', reducer, list);\n */\nexport const reduce = nary(initial => reducer => list => list.reduce(reducer, initial));\n\n/**\n * reduceRight executes input reducer function that over each member of input array [b] to output a single value. It is\n * the preferred way of working functionally with arrays as it is a pure function that does not cause mutations.\n *\n * reduceRight executes functions in reverse order to reduce.\n *\n * reduceRight can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner reduceRight :: a -> ((a, b) -> a) -> [b] -> a\n *\n * @pure\n * @param {*} initial\n * @param {function} reducer\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {reduceRight} from '@7urtle/lambda';\n *\n * const reducer = (accumulator, currentValue) => accumulator + currentValue;\n * const list = ['a', 'b', 'c'];\n *\n * reduceRight('start')(reducer)(list); // => startcba\n *\n * // reduceRight can be called both as a curried unary function or as a standard ternary function\n * reduceRight('start')(reducer)(list) === reduceRight('start', reducer, list);\n */\nexport const reduceRight = nary(initial => reducer => list => list.reduceRight(reducer, initial));\n\n/**\n * filter executes input checker over each member of input array [a] to filter and output filtered new array [b].\n *\n * If you need to both filter and map over an array, consider using the filterMap function.\n *\n * filter can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner filter :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {filter} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n *\n * filter(a => a > 1)(list); // => [2, 3]\n *\n * // filter can be called both as a curried unary function or as a standard binary function\n * filter(a => a > 1)(list) === filter(a => a > 1, list);\n */\nexport const filter = nary(checker => list => list.filter(checker));\n\n/**\n * filterMap executes mapper function over filtered input array or monad and outputs the resulting array or monad.\n *\n * Only one pass through the array is executed unlike the use of map(mapper)(filter(checker)(list)).\n *\n * filterMap can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner filterMap :: (a -> boolean) -> (a -> b) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {function} mapper\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {filterMap} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n * const mapper = a => a + 1;\n * const checker = a => a > 1;\n *\n * filterMap(checker)(mapper)(list);  // => [3, 4]\n * filterMap(a => a > 1)(a => a + 1)([0, 1, 2, 3]); // => [3, 4]\n *\n * const mapOverLargerThanOne = filterMap(checker);\n * mapOverLargerThanOne(mapper)(list); // => [3, 4]\n *\n * // filterMap can be called both as a curried unary function or as a standard ternary function\n * filterMap(a => a > 1)(a => a + 1)(list) === filterMap(a => a > 1, a => a + 1, list);\n */\nexport const filterMap = nary(checker => mapper => list =>\n    reduce([])((acc, current) => checker(current) ? acc.push(mapper(current)) && acc : acc)(list));\n\n/**\n * find executes input checker over each member of input array [a] and outputs the first array member that matches checker or undefined.\n *\n * find can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner find :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {find} from '@7urtle/lambda';\n *\n * const list = [0, 1, 2, 3]\n *\n * find(a => a > 1)(list); // => 2\n * find(a => a > 3)(list); // => undefined\n *\n * // find can be called both as a curried unary function or as a standard binary function\n * find(a => a > 1)(list) === find(a => a > 1, list);\n */\nexport const find = nary(checker => list => list.find(checker));\n\n/**\n * findIndex executes input checker over each member of input array [a] and outputs the index of first array member that matches checker or undefined.\n *\n * findIndex can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner findIndex :: (a -> boolean) -> [a] -> [b]\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {findIndex} from '@7urtle/lambda';\n *\n * const list = [2, 3, 4];\n *\n * findIndex(a => a > 2)(list); // => 1\n * findIndex(a => a > 4)(list); // => undefined\n *\n * // findIndex can be called both as a curried unary function or as a standard binary function\n * findIndex(a => a > 1)(list) === findIndex(a => a > 1, list);\n */\nexport const findIndex = nary(checker => list => minusOneToUndefined(list.findIndex(checker)));\n\n/**\n * join outputs a string created by joining input array members with input separator.\n *\n * join can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner join :: string -> [a] -> string\n *\n * @pure\n * @param {string} separator\n * @param {array} list\n * @return {*}\n *\n * @example\n * import {join} from '@7urtle/lambda';\n *\n * const list = [2, 3, 4];\n *\n * join('')(list); // => '234'\n * join(' and ')(list); // => '2 and 3 and 4'\n * join()(list); // => '2,3,4'\n *\n * // join can be called both as a curried unary function or as a standard binary function\n * join('')(list) === join('', list);\n */\nexport const join = nary(separator => list => list.join(separator));\n\n/**\n * keysOf outputs array of string keys of input array or object.\n *\n * @HindleyMilner keysOf :: object -> [string]\n *\n * @pure\n * @param {Object|array} list\n * @return {array}\n *\n * @example\n * import {keysOf} from '@7urtle/lambda';\n *\n * keysOf([2, 3, 4]); // => ['0', '1', '2']\n * keysOf({1: 2, 2: 3}); // => ['1', '2']\n */\nexport const keysOf = Object.keys;\n\n/**\n * entriesOf outputs array of arrays of string keys and raw values of input array or object.\n *\n * @HindleyMilner entriesOf :: object -> [[string, a]]\n *\n * @pure\n * @param {Object|array} list\n * @return {array}\n *\n * @example\n * import {entriesOf} from '@7urtle/lambda';\n *\n * entriesOf([2, 3, 4]); // => [['0', 2], ['1', 3], ['2', 4]]\n * entriesOf({1: 2, 2: 3}); // => [['1', 2],['2', 3]]\n */\nexport const entriesOf = Object.entries;\n\n/**\n * everyOf outputs true if every element of input array passes input checker function as true.\n *\n * everyOf can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner everyOf :: (a -> boolean) -> [a] -> boolean\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {boolean}\n *\n * @example\n * import {everyOf} from '@7urtle/lambda';\n *\n * everyOf(a => a > 1)([2, 3, 4]); // => true\n * everyOf(a => a > 5)([2, 3, 4]); // => false\n *\n * // everyOf can be called both as a curried unary function or as a standard binary function\n * everyOf(a => a > 1)([2, 3, 4]) === everyOf(a => a > 1, [2, 3, 4]);\n */\nexport const everyOf = nary(checker => list => list.every(checker));\n\n/**\n * slice outputs selected array elements as an array based on input range. First argument end\n * represents the ending index (not length) and start represents the starting index in the input\n * array list.\n *\n * slice can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner slice :: number -> number -> [a] -> [a]\n *\n * @pure\n * @param {number} end\n * @param {number} start\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {slice} from '@7urtle/lambda';\n *\n * slice(2)(1)([1, 2, 3, 4, 5]); // => [2]\n * slice(2)(0)([1, 2, 3, 4, 5]); // => [1, 2]\n * slice(8)(7)([1, 2, 3, 4, 5]); // => []\n *\n * // slice can be called both as a curried unary function or as a standard ternary function\n * slice(2)(1)([1, 2, 3, 4, 5]) === slice(2, 1, [1, 2, 3, 4, 5]);\n */\nexport const slice = nary(end => start => list => list.slice(start, end));\n\n/**\n * some outputs true if any element of input array passes input checker function as true.\n *\n * some can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner some :: (a -> boolean) -> [a] -> boolean\n *\n * @pure\n * @param {function} checker\n * @param {array} list\n * @return {boolean}\n *\n * @example\n * import {some} from '@7urtle/lambda';\n *\n * someOf(a => a > 1)([2, 3, 4]); // => true\n * someOf(a => a > 5)([2, 3, 4]); // => false\n *\n * // some can be called both as a curried unary function or as a standard binary function\n * someOf(a => a > 1)([2, 3, 4]) === someOf(a => a > 1, [2, 3, 4]);\n */\nexport const someOf = nary(checker => list => list.some(checker));\n\n/**\n * sort outputs an array sorted based on input compare function.\n *\n * sort can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner sort :: (a -> number) -> [a] -> [a]\n *\n * @pure\n * @param {function} compare\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sort} from '@7urtle/lambda';\n *\n * sort((a, b) => a < b ? -1 : a > b ? 1 : 0)(['a', 'd', 'c', 'd']); // => ['a', 'c', 'd', 'd']\n * sort((a, b) => a - b)([5, 3, 6]); // => [3, 5, 6]\n *\n * // sort can be called both as a curried unary function or as a standard binary function\n * sort((a, b) => a - b)([5, 3, 6]) === sort((a, b) => a - b, [5, 3, 6]);\n */\nexport const sort = nary(compare => list => [...list].sort(compare));\n\n/**\n * sortAlphabetically outputs an array sorted alphabetically from a to z.\n *\n * @HindleyMilner sortAlphabetically :: [string] -> [string]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortAlphabetically} from '@7urtle/lambda';\n *\n * sortAlphabetically(['petra', 'Martin', 'Petra']); // => ['Martin', 'petra', 'Petra']\n */\nexport const sortAlphabetically = sort((a, b) => (a => b => a < b ? -1 : a > b ? 1 : 0)(upperCaseOf(a))(upperCaseOf(b)));\n\n/**\n * sortAlphabeticallyZA outputs an array sorted alphabetically from z to a.\n *\n * @HindleyMilner sortAlphabeticallyZA :: [string] -> [string]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortAlphabeticallyZA} from '@7urtle/lambda';\n *\n * sortAlphabeticallyZA(['petra', 'Martin', 'Petra']); // => ['petra', 'Petra', 'Martin']\n */\nexport const sortAlphabeticallyZA = sort((a, b) => (a => b => a < b ? 1 : a > b ? -1 : 0)(upperCaseOf(a))(upperCaseOf(b)));\n\n/**\n * sortNumerically outputs an array sorted numerically from 1 to 2.\n *\n * @HindleyMilner sortNumerically :: [number] -> [number]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortNumerically} from '@7urtle/lambda';\n *\n * sortNumerically([3, 4, 1, 3]); // => [1, 3, 3, 4]\n */\nexport const sortNumerically = sort((a, b) => a - b);\n\n/**\n * sortNumerically21 outputs an array sorted numerically from 2 to 1.\n *\n * @HindleyMilner sortNumerically21 :: [number] -> [number]\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {sortNumerically21} from '@7urtle/lambda';\n *\n * sortNumerically21([3, 4, 1, 3]); // => [4, 3, 3, 1]\n */\nexport const sortNumerically21 = sort((a, b) => b - a);\n\n/**\n * headOf outputs the first item (head) from the input array.\n *\n * @HindleyMilner headOf :: [a] -> a\n *\n * @pure\n * @param {array} list\n * @return {any}\n *\n * @example\n * import {headOf} from '@7urtle/lambda';\n *\n * headOf([3, 4, 1, 8]); // => 3\n * headOf([8]); // => 8\n * headOf([]); // => undefined\n */\nexport const headOf = list => list[0];\n\n/**\n * tailOf outputs the the input array without its first item.\n *\n * @HindleyMilner tailOf :: [a] -> []\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {tailOf} from '@7urtle/lambda';\n *\n * tailOf([3, 4, 1, 8]); // => [4, 1, 8]\n * tailOf([8]); // => []\n * tailOf([]); // => []\n */\nexport const tailOf = list => list.slice(1);\n\n/**\n * initOf outputs the the input array without its last item.\n *\n * @HindleyMilner initOf :: [a] -> []\n *\n * @pure\n * @param {array} list\n * @return {array}\n *\n * @example\n * import {initOf} from '@7urtle/lambda';\n *\n * initOf([3, 4, 1, 8]); // => [3, 4, 1]\n * initOf([8]); // => []\n * initOf([]); // => []\n */\nexport const initOf = list => slice(lengthOf(list) -1)(0)(list);\n\n/**\n * lastOf outputs the last item from the input array.\n *\n * @HindleyMilner lastOf :: [a] -> a\n *\n * @pure\n * @param {array} list\n * @return {any}\n *\n * @example\n * import {lastOf} from '@7urtle/lambda';\n *\n * lastOf([3, 4, 1, 8]); // => 8\n * lastOf([3]); // => 3\n * lastOf([]); // => undefined\n */\nexport const lastOf = list => list[lengthOf(list) -1];\n\n/**\n * groupBy outputs an objects with groups produced by an input function over input list.\n *\n * groupBy can be called both as a curried unary function or as a standard binary function.\n *\n * @HindleyMilner groupBy :: (a -> b) -> [a] -> {b: a}\n *\n * @pure\n * @param {function} fn\n * @param {array} list\n * @return {object}\n *\n * @example\n * import {groupBy} from '@7urtle/lambda';\n *\n * groupBy(a => a.length)(['one', 'two', 'three']);\n * // => {\"3\": [\"one\", \"two\"], \"5\": [\"three\"]}\n *\n * groupBy(a => a % 2)([1, 2, 3]);\n * // =>  {\"0\": [2], \"1\": [1, 3]}\n *\n * // groupBy can be called both as a curried unary function or as a standard binary function\n * groupBy(a => a.length)(['one', 'two', 'three']) === groupBy(a => a.length, ['one', 'two', 'three'])\n */\nexport const groupBy = nary(fn => list =>\n    reduce\n    ({})\n    ((acc, current) =>\n        (acc[fn(current)] = acc[fn(current)] || []).push(current) && acc\n    )\n    (list));\n\n/**\n * randomOf outputs a random item from the input array.\n *\n * @HindleyMilner randomOf :: [a] -> a\n *\n * @pure\n * @param {array} list\n * @return {any}\n *\n * @example\n * import {randomOf} from '@7urtle/lambda';\n *\n * randomOf([3, 4, 1, 8]); // => 8\n * randomOf([3]); // => 3\n * randomOf([]); // => undefined\n */\nexport const randomOf = list => list[Math.floor(Math.random() * lengthOf(list))];","import {deepInspect} from \"./utils.js\";\nimport {isUndefined} from \"./conditional.js\";\n\n/**\n * Case is a monad that helps you with conditional processing.\n *\n * Case expects an array of key-value pairs as its input. Case.match then matches against a key to provide its value.\n *\n * Case is internally build on a JavaScript map and turns it into an applicative functor monad.\n *\n * @example\n * import {Case, upperCaseOf, liftA2} from '@7urtle/lambda';\n *\n * // in the example we define Case using key-value pairs. Case.of() outputs an instance of Case.\n * const myCase = Case.of([[1, 'one'], ['key', 'value'], ['_', 'fallback']]);\n *\n * // you reach a value by matching keys using Case.match\n * myCase.match(1); // => 'one'\n * myCase.match('key'); // => 'value'\n * myCase.match('nope'); // => 'fallback'\n *\n * // if no fallback is defined and no key is matched, we return undefined\n * Case.of([]).match('nope'); // => undefined\n *\n * // you can also inspect it by\n * myCase.inspect(); // => 'Case(...\n *\n * // as a functor the result is safely mappable (map doesn't execute over undefined matches)\n * myCase.map(value => upperCaseOf(value)).match('key'); // => 'VALUE'\n * Case.of([]).map(upperCaseOf).match('key'); // => undefined\n *\n * // as a monad Case can be safely flat mapped with other Cases (flatMap doesn't execute over undefined)\n * Case.of([[1, 'I am']]).flatMap(a => Case.of([[1, a + ' a turtle']]).match(1); // => 'I am a turtle'\n * Case.of([[1, 'I am']]).flatMap(a => Case.of([])).match(1); // => undefined\n *\n * // as an applicative functor you can apply Cases to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(Case.of([[1, 1]]))(Case.of([[1, 2]])).match(1); // => 3\n * Case.of([[1, add]]).ap(Case.of([[1, 'I am']])).ap(Case.of([[1, ' a turtle']])).match(1); // => 'I am a turtle'\n * Case.of([[1, add]]).ap(Case.of([])).ap(Case.of([[1, 'I am']])).match(1); // => undefined\n */\nexport const Case = {\n  of: match => getCase((match => a => match.get(a) || match.get('_') || undefined)(new Map(match)))\n};\n\nconst getCase = match => ({\n  match: match,\n  inspect: () => `Case(${deepInspect(match)})`,\n  map: fn => getCase(a => (result => isUndefined(result) ? result : fn(result))(match(a))),\n  flatMap: fn => getCase(a => (result => isUndefined(result) ? undefined : result.match(a))(getCase(match).map(fn).match(a))),\n  ap: f => getCase(match).flatMap(fn => f.map(fn))\n});","import { deepInspect } from \"./utils.js\";\nimport { nary } from \"./arity.js\";\nimport { isFunction } from \"./conditional.js\";\nimport { map } from \"./core.js\";\n\n/**\n * AsyncEffect is a monad that allows you to safely work with asynchronous side effects in JavaScript.\n *\n * AsyncEffect expects as its input a function that takes two inputs of a reject function, and a resolve\n * function. Reject function is called on failure and resolve function is called on success. It is similar\n * to using JavaScript Promise and AsyncEffect can be directly created from a Promise turning it into a monad.\n *\n * AsyncEffect is evaluated lazily and nothing is executed until a trigger function is called.\n *\n * AsyncEffect can also be called Future monad in other libraries or languages.\n *\n * @example\n * import {AsyncEffect, log, upperCaseOf, liftA2, liftA3} from '@7urtle/lambda';\n *\n * // we create AsyncEffect that expects a number from 0 to 1\n * // and based on that, it resolve or rejects 10 milliseconds after it is triggered\n * const myAsyncEffect = AsyncEffect\n * .of(reject => resolve =>\n *     setTimeout(() => Math.random() > 0.5 ? resolve('random success') : reject('random failure'), 10)\n * );\n *\n * // we could also create AsyncEffect from a function returning JavaScript Promise\n * const myPromise = () => new Promise((resolve, reject) =>\n *     setTimeout(() => Math.random() > 0.5 ? resolve('random success') : reject('random failure'), 10)\n * );\n * const promiseAsyncEffect = AsyncEffect.ofPromise(myPromise);\n *\n * // you can inspect AsyncEffect by\n * myAsyncEffect.inspect(); // => \"AsyncEffect(function...\n *\n * // when you are ready, you can call trigger to trigger the side effect\n * // nothing is executed until the trigger is called\n * myAsyncEffect\n * .trigger\n * (error => log(error))\n * (result => log(result));\n * // => logs 'random success' or 'random failure' depending on Math.random() value\n *\n * // you can also turn AsyncEffect into a JavaScript Promise\n * myAsyncEffect\n * .promise()\n * .then(result => log(result), error => log(error));\n * // => logs 'random success' or 'random failure' depending on Math.random() value\n *\n * // thrown exceptions lead AsyncEffect to reject\n * AsyncEffect\n * .of(() => {\n *     throw 'error';\n * })\n * .trigger(log)(log);\n * // => logs 'error'\n *\n * // as a functor the value inside is safely mappable\n * // map doesn't execute in case of an error and nothing executes until a trigger is called\n * myAsyncEffect\n * .map(value => upperCaseOf(value))\n * .trigger(log)(log);\n * // => logs 'RANDOM SUCCESS' or 'random failure' depending on Math.random() value\n *\n * // as a monad AsyncEffect can be safely flat mapped with other AsyncEffects\n * // flatMap doesn't execute in case of an error and nothing executes until a trigger is called\n * AsyncEffect\n * .of(reject => resolve => resolve('7urtle'))\n * .flatMap(a => AsyncEffect.of(reject => resolve => resolve(a + 's')))\n * .trigger(log)(log);\n * // => logs '7urtles'\n *\n * // as an applicative functor you can apply AsyncEffects to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * const AS1 = AsyncEffect.of(reject => resolve => resolve(1));\n * const AS2 = AsyncEffect.of(reject => resolve => resolve(2));\n * liftA2(add)(AS1)(AS2); // => resolve(3)\n *\n * const ASFail = AsyncEffect.of(() => {throw 'error'});\n * liftA3(add)(ASFail)(AS1)(AS2); // => reject('error')\n *\n * // AsyncEffect.of as well as AsyncEffect.trigger accept both curried and binary functions\n * AsyncEffect.of((reject, resolve) => resolve('7urtle')).trigger(log, log); // logs '7urtle'\n *\n * // as an example you can use AsyncEffect to help you work with axios or fs\n *\n * // axios example\n * import axios from 'axios';\n * const getFromURL = url => AsyncEffect.ofPromise(() => axios.get(url));\n *\n * getFromURL('/my/ajax/url')\n * .trigger\n * (error => log(error))\n * (result => log(result.data));\n *\n * // reading file example\n * import fs from 'fs';\n * const readFile => input =>\n *     AsyncEffect\n *     .of(reject => resolve =>\n *         fs.readFile(input, (err, data) =>\n *             err ? reject(err) : resolve(data)\n *         )\n *     );\n *\n * readFile('./file.txt')\n * .trigger\n * (error => log(error))\n * (result => log(result));;\n */\nexport const AsyncEffect = {\n  of: trigger => getAsyncEffect(nary(reject => resolve => {\n    try {\n      const result = trigger(reject, resolve);\n      return isFunction(result) ? result(resolve) : result;\n    } catch(error) {\n      reject(error);\n    }\n  })),\n  ofPromise: promise => AsyncEffect.of(reject => resolve =>\n      promise().then(resolve).catch(reject)\n  )\n};\n\nconst getAsyncEffect = trigger => ({\n  trigger: trigger,\n  inspect: () => `AsyncEffect(${deepInspect(trigger)})`,\n  promise: () => new Promise((resolve, reject) => trigger(reject)(resolve)),\n  map: fn => getAsyncEffect(nary(reject => resolve => trigger(reject)(a => resolve(fn(a))))),\n  flatMap: fn => getAsyncEffect(nary(reject => resolve => trigger(reject)(x => fn(x).trigger(reject)(resolve)))),\n  ap: f => getAsyncEffect(trigger).flatMap(fn => f.map(fn))\n});\n\n/**\n * mergeAsyncEffects outputs AsyncEffect which resolves with array of all input AsyncEffects or rejects with the first effect rejected.\n *\n * @HindleyMilner mergeAsyncEffects :: ([AsyncEffect]) -> AsyncEffect\n *\n * @pure\n * @param {AsyncEffect} asyncEffects\n * @return {AsyncEffect}\n *\n * @example\n * import { mergeAsyncEffects, AsyncEffect } from '@7urtle/lambda';\n * \n * const resolvingOne = AsyncEffect.of(_ => resolve => resolve('Resolving One'));\n * const resolvingTwo = AsyncEffect.of(_ => resolve => resolve('Resolving Two'));\n *\n * mergeAsyncEffects(resolvingOne, resolvingTwo)\n * .trigger(console.log)(console.log);\n * // => logs ['Resolving One', 'Resolving Two']\n * \n * const rejectingOne = AsyncEffect.of(reject => _ => reject('Rejecting One'));\n * const rejectingTwo = AsyncEffect.of(reject => _ => reject('Rejecting Two'));\n * \n * mergeAsyncEffects(resolvingOne, rejectingOne, rejectingTwo, resolvingTwo)\n * .trigger(console.log)(console.log);\n * // => logs 'Rejecting One'\n */\nexport const mergeAsyncEffects = (...asyncEffects) =>\n  AsyncEffect\n  .ofPromise(\n      () => Promise.all(map(a => a.promise())(asyncEffects))\n  );","import { deepInspect } from \"./utils.js\";\nimport { Maybe, Nothing } from './Maybe.js';\nimport { Either } from './Either.js';\nimport { AsyncEffect } from './AsyncEffect.js';\n\n/**\n * SyncEffect is a monad that allows you to safely work with synchronous side effects in JavaScript.\n *\n * SyncEffect expects as its input a function.\n *\n * SyncEffect is evaluated lazily and nothing is executed until a trigger function is called. It does not have any inner error/exception handling\n * mechanism for the effects of the trigger. Consider using the monads Maybe and Either for managing\n * the results of the trigger.\n *\n * In other languages and framework, SyncEffect can be also called the IO monad.\n *\n * @example\n * import {SyncEffect, log, upperCaseOf, liftA2, Either, isNull} from '@7urtle/lambda';\n *\n * // we create SyncEffect that expects a number from 0 to 1\n * // and based on that, it returns a value or throws an error\n * const throwError = () => {throw 'random failure'};\n * const dangerousFunction = value => value > 0.5 ? 'random success' : throwError();\n * const mySyncEffect = SyncEffect.of(dangerousFunction);\n *\n * // when you are ready, you can call trigger to trigger the side effect\n * // nothing is executed until the trigger is called\n * mySyncEffect.trigger(Math.random());\n * // => returns 'random success' or throws 'random failure' depending on Math.random() value\n *\n * // you can inspect SyncEffect by\n * mySyncEffect.inspect(); // => \"SyncEffect(function...\n *\n * // as a functor the value inside is safely mappable\n * // map doesn't execute in case of an error and nothing executes until a trigger is called\n * mySyncEffect\n * .map(value => upperCaseOf(value))\n * .trigger(Math.random());\n * // => returns 'RANDOM SUCCESS' or throws 'random failure' depending on Math.random() value\n *\n * // as a monad SyncEffect can be safely flat mapped with other SyncEffects\n * // flatMap doesn't execute in case of an error and nothing executes until a trigger is called\n * SyncEffect.of(() => '7turtle').flatMap(a => SyncEffect.of(() => a + 's')).trigger();\n * // => '7urtles'\n * SyncEffect.of(() => {throw 'error'}).flatMap(a => SyncEffect.of(() => a + 's')).trigger();\n * // => throws 'error'\n *\n * // as an applicative functor you can apply SyncEffects to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(SyncEffect.of(() => 1)(SyncEffect.of(() => 2)).trigger(); // => 3\n * SyncEffect.of(() => add).ap(SyncEffect.of(() => 1)).ap(SyncEffect.of(() => 2)).trigger(); // => 3\n *\n * // in practice you can use SyncEffect to work for example with DOM\n * const DOMSyncEffect = SyncEffect.of(targetID => document.querySelector(targetID));\n * const TopOffsetSyncEffect = DOMSyncEffect.map(a => a.offsetTop);\n * const ClientHeightSyncEffect = DOMSyncEffect.map(a => a.clientHeight);\n *\n * TopOffsetSyncEffect.trigger('article'); // 1280\n * Either.try(ClientHeightSyncEffect.trigger('#dontexist')); // Failure('Uncaught TypeError: Cannot read property 'offsetTop' of null')\n */\nexport const SyncEffect = {\n  of: trigger => getSyncEffect(trigger)\n};\n\nconst getSyncEffect = trigger => ({\n  trigger: trigger,\n  inspect: () => `SyncEffect(${deepInspect(trigger)})`,\n  map: fn => getSyncEffect(a => fn(trigger(a))),\n  flatMap: fn => getSyncEffect(() => getSyncEffect(trigger).map(fn).trigger().trigger()),\n  ap: f => getSyncEffect(trigger).flatMap(fn => f.map(fn))\n});\n\n/**\n * syncEffectToMaybe converts any SyncEffect monad to a Maybe monad with\n * Maybe Nothing if SyncEffect throws an error.\n *\n * @HindleyMilner syncEffectToMaybe :: SyncEffect -> Maybe\n *\n * @pure\n * @param {SyncEffect} syncEffectMonad\n * @return {Maybe}\n *\n * @example\n * import { syncEffectToMaybe, SyncEffect } from '@7urtle/lambda';\n *\n * eitherToMaybe(SyncEffect.of(() => '7urtle')); // => Just('7urtle')\n * eitherToMaybe(SyncEffect.of(() => undefined)); // => Nothing\n * eitherToMaybe(SyncEffect.of(() => { throw 'I am an error.'; }))); // => Nothing\n */\nexport const syncEffectToMaybe = syncEffectMonad => {\n  try {\n    return Maybe.of(syncEffectMonad.trigger());\n  } catch(error) {\n    return Nothing;\n  }\n};\n\n/**\n * syncEffectToEither converts any SyncEffect monad to an Either monad with\n * Either Failure containing SyncEffect thrown error.\n *\n * @HindleyMilner syncEffectToEither :: SyncEffect -> Either\n *\n * @pure\n * @param {SyncEffect} syncEffectMonad\n * @return {Either}\n *\n * @example\n * import { syncEffectToEither, SyncEffect } from '@7urtle/lambda';\n *\n * syncEffectToEither(SyncEffect.of(() => '7urtle')); // => Success('7urtle')\n * syncEffectToEither(SyncEffect.of(() => { throw 'I am an error.'; })); // => Failure('I am an error.')\n */\nexport const syncEffectToEither = syncEffectMonad => Either.try(syncEffectMonad.trigger);\n\n/**\n * syncEffectToAsyncEffect converts any SyncEffect monad to a AsyncEffect monad with\n * AsyncEffect rejecting thrown error.\n *\n * @HindleyMilner syncEffectToAsyncEffect :: SyncEffect -> AsyncEffect\n *\n * @pure\n * @param {SyncEffect} syncEffectMonad\n * @return {AsyncEffect}\n *\n * @example\n * import { syncEffectToAsyncEffect, SyncEffect } from '@7urtle/lambda';\n *\n * syncEffectToAsyncEffect(SyncEffect.of(() => '7urtle')); // resolves to '7urtle'\n * syncEffectToAsyncEffect(SyncEffect.of(() => { throw 'I am an error.'; })); // rejects 'I am an error.'\n */\n export const syncEffectToAsyncEffect = syncEffectMonad => \n  AsyncEffect\n  .of(_ => resolve =>\n    resolve(syncEffectMonad.trigger())\n  );","import { deepInspect } from './utils.js';\nimport { nary } from './arity.js';\nimport { reduce } from './list.js';\nimport { Maybe, Nothing } from './Maybe.js';\nimport { SyncEffect } from './SyncEffect.js';\nimport { AsyncEffect } from './AsyncEffect.js';\n\nexport const Failure = value => ({\n  value: value,\n  inspect: () => `Failure(${deepInspect(value)})`,\n  isFailure: () => true,\n  isSuccess: () => false,\n  map: () => Failure(value),\n  flatMap: () => Failure(value),\n  catchMap: fn => Failure(fn(value)),\n  bimap: nary(leftFn => _ => Failure(leftFn(value))),\n  ap: () => Failure(value),\n  orOf: a => Success(a),\n  orElse: fn => fn(),\n  orTry: fn => Either.try(fn)\n});\n\nexport const Success = value => ({\n  value: value,\n  inspect: () => `Success(${deepInspect(value)})`,\n  isFailure: () => false,\n  isSuccess: () => true,\n  map: fn => Success(fn(value)),\n  catchMap: () => Success(value),\n  bimap: nary(_ => rightFn => Success(rightFn(value))),\n  flatMap: fn => fn(value),\n  ap: m => m.map(value),\n  orOf: () => Success(value),\n  orElse: () => Success(value),\n  orTry: () => Success(value)\n});\n\n/**\n * Either is an excellent monad for handling error states and it is fairly similar to our monad Maybe. Either.Failure\n * represents an error state and Either.Success represents a success state.\n *\n * Either.of expects a value as its input. Either.of is the same as Either.Success. You can initiate Either\n * in its error state by Either.Failure.\n *\n * You can also initiate it using Either.try which expects a function as an input. It is Failure if an error\n * or exception is thrown. It is Success if there are no errors or exceptions.\n *\n * Either is called Either because it allows you to branch based on an error state. You want to use Either\n * for situations when you don't know whether there might be an error. It makes the very visible that an error\n * can occur and it forces the consumer to handle the situation.\n *\n * @example\n * import {either, Either, Success, Failure, upperCaseOf, liftA2} from '@7urtle/lambda';\n *\n * // in the example we randomly give Either a value or throw an error. Either.try() outputs an instance of Either.\n * const myEither = Either.try(() => Math.random() > 0.5 ? 'random success' : throw 'random failure');\n *\n * // you can also return Either.Failure or Either.Success based on a function logic\n * const myFunction = Math.random() > 0.5 ? Either.Success('random success') : Either.Failure('random failure');\n * \n * // Success and Failure can be called directly\n * Success('7urtle') === Either.Success('7urtle'); // => true\n * Success('7urtle') === Either.of('7urtle'); // => true\n * Failure('error') === Either.Failure('error'); // => true\n *\n * // you could access the actual value like this\n * myEither.value; // => 'random success' or 'random failure'\n *\n * // you can also inspect it by\n * myEither.inspect(); // => \"Success('random success')\" or Failure('random failure')\n *\n * // Either.of and Either.Success both represent success states\n * Either.of('some value').inspect() === Success('some value').inspect(); // => true\n *\n * // you can check if the value is Failure\n * myEither.isFailure(); // => true or false\n * Either.of('abc').isFailure(); // => false\n * Success('anything').isFailure(); // => false\n * Failure('anything').isFailure(); // => true\n * Either.try(() => {throw 'error'}).isFailure(); // => true\n *\n * // you can check if the value is Success\n * myEither.isSuccess(); // => true or false\n * Either.of('abc').isSuccess(); // => true\n * Success('anything').isSuccess(); // => true\n * Failure('anything').isSuccess(); // => false\n * Either.try(() => {throw 'error'}).isSuccess(); // => false\n *\n * // as a functor the value inside is safely mappable (map doesn't execute over Failure)\n * myEither.map(value => upperCaseOf(value));\n * myEither.inspect(); // => \"Success('RANDOM SUCCESS')\" or \"Failure('random failure')\"\n *\n * // as a monad Either can be safely flat mapped with other Eithers (flatMap doesn't execute over Failure)\n * Either.of(3).flatMap(a => Either.of(a + 2)).inspect(); // => 'Success(5)'\n * Failure(3).flatMap(a => Either.of(null)).inspect(); // => 'Failure(3)'\n * Either.of(3).flatMap(a => a + 2); // => 5\n * \n * // you can use catchMap if you want to map over Failure\n * Failure('error').catchMap(a => a + 's'); // => Failure('errors')\n * Success('7urtle').catchMap(a => a + 's'); // => Success('7urtle') \n * \n * // you can use bimap to map over both Success and Failure with different functions\n * Failure('error').bimap(a + ' is left')(a => a + ' is right');  // => Failure('error is left')\n * Succcess('7urtle').bimap(a + ' is left')(a => a + ' is right'); // => Success('7urtle is right')\n * \n * // orOf(a) replaces Failure with Success\n * Failure('error').orOf('7urtles'); // => Success('7urtle')\n * Success('7urtle').orOf('tortoise'); // => Success('7urtle')\n * \n * // orElse(a -> Either) replaces Failure with the output of orElse function\n * Failure('error').orElse(() => Success('7urtle')); // => Success('7urtle')\n * Success('7urtle').orElse(() => Success('tortoise')); // => Success('7urtle')\n * \n * // orTry(a -> b) replaces original Fairlure with Either.try\n * Failure('error').orTry(() => { throw 'i am an error'; }); // => Failure('i am an error')\n * Failure('error').orTry(() => '7urtle'); // => Success('7urtle')\n * Success('7urtle').orTry(() => { throw 'i am an error'; }); // => Success('7urtle')\n *\n * // as an applicative functor you can apply Eithers to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(Either.of(2))(Either.of(3)); // => Success(5)\n * Either.of(1).map(add).ap(Either.of(2)).inspect(); // => 'Success(3)'\n * Failure(1).map(add).ap(Either.of(2)).inspect(); // => 'Failure(1)'\n * Either.of(add).ap(Either.of(1)).ap(Either.of(2)).inspect(); // => 'Success(3)'\n */\nexport const Either = {\n  of: value => Success(value),\n  Success: value => Success(value),\n  Failure: value => Failure(value),\n  try: fn => {\n    try {\n      return Success(fn());\n    } catch(error) {\n      return Failure(error.message || error);\n    }\n  }\n};\n\n/**\n * either outputs result of a function onRight if input Either is Success or outputs result of a function onLeft if input Either is Failure.\n *\n * either can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner either :: (a -> b) -> (b -> c) -> Either\n *\n * @pure\n * @param {function} onFailure\n * @param {function} onSuccess\n * @param {Either} functorEither\n * @return {*}\n *\n * @example\n * import {either, Either} from '@7urtle/lambda';\n *\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.of('abc')); // => 'success abc'\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.Failure('failure')); // => 'error failure'\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.try(() => throw 'failure')); // => 'error failure'\n *\n * // either can be called both as a curried unary function or as a standard ternary function\n * either(a => 'error ' + a)(a => 'success ' + a)(Either.of('abc')) === either(a => 'error ' + a, a => 'success ' + a, Either.of('abc'));\n */\nexport const either = nary(onFailure => onSuccess => functorEither =>\n  functorEither.isFailure()\n    ? onFailure(functorEither.value)\n    : onSuccess(functorEither.value)\n);\n\n/**\n * mergeEithers outputs Either of array with all Either values depending whether they are Success or Failure.\n *\n * @HindleyMilner mergeEithers :: ([Either]) -> Either\n *\n * @pure\n * @param {Either} eithers\n * @return {Either}\n *\n * @example\n * import { mergeEithers, Either } from '@7urtle/lambda';\n *\n * mergeEithers(Either.of('abc'), Either.of('def')); //  => Success(['abc', 'def'])\n * mergeEithers(Either.of('abc'), Either.Failure('def')); // => Failure(['def'])\n * mergeEithers(Either.Failure('abc'), Either.of('def')); // => Failure(['abc'])\n * mergeEithers(Either.Failure('abc'), Either.Failure('def')); // => Failure(['abc', 'def'])\n */\nexport const mergeEithers = (...eithers) =>\n  reduce\n  (Success([]))\n  ((accumulator, current) =>\n    current.isFailure()\n    ? accumulator.isFailure() // current Either is Failure\n      ? Failure([...accumulator.value, current.value]) // accumulator is Failure and current is Failure => update accumulator\n      : Failure([current.value]) // accumulator is Success and current is Failure => return first Failure\n    : accumulator.isFailure() // current Either is Success\n      ? accumulator // accumulator is Failure and current is Success => return accumulator\n      : Success([...accumulator.value, current.value]) // accumulator is Success and current is Success => update accumulator\n  )\n  (eithers);\n\n/**\n * validateEithers outputs Either of input value if all input functions returns Success or Failure\n * with array of error messages.\n *\n * @HindleyMilner validateEithers :: ([a -> b]) -> a -> Either\n *\n * @pure\n * @param {functions} fns\n * @param {*} input\n * @return {Either}\n *\n * @example\n * import { validateEithers, Either, isAtLeast, lengthOf } from '@7urtle/lambda';\n *\n * // mergeEithers is great to be used for validations\n * const isPasswordLongEnough = password =>\n *  isAtLeast(6)(lengthOf(password))\n *  ? Either.Success(password)\n *  : Either.Failure('Password must have more than 6 characters.');\n * \n * const isPasswordStrongEnough = password =>\n *  /[\\W]/.test(password)\n *  ? Either.Success(password)\n *  : Either.Failure('Password must contain special characters.');\n * \n * const validatePassword = validateEithers(isPasswordLongEnough, isPasswordStrongEnough);\n * \n * validatePassword('LongPa$$word'); // => Success('LongPa$$word')\n * validatePassword('Pa$$'); // => Failure(['Password must have more than 6 characters.'])\n * validatePassword('LongPassword'); // => Failure(['Password must contain special characters.'])\n * validatePassword('Pass'); // => Failure(['Password must have more than 6 characters.', 'Password must contain special characters.'])\n */\nexport const validateEithers = (...fns) => input =>\n  reduce\n  (Success(input))\n  ((accumulator, currentFn) =>\n    (currentResult =>\n      currentResult.isFailure()\n      ? accumulator.isFailure() // currentResult Either is Failure\n        ? Failure([...accumulator.value, currentResult.value]) // accumulator is Failure and currentResult is Failure => update accumulator\n        : Failure([currentResult.value]) // accumulator is Success and currentResult is Failure => return first Failure\n      : accumulator // currentResult Either is Success\n    )(currentFn(input))\n  )\n  (fns);\n\n/**\n * eitherToMaybe converts any Either monad to a Maybe monad with\n * Maybe Nothing if Either is Failure.\n *\n * @HindleyMilner eitherToMaybe :: Either -> Maybe\n *\n * @pure\n * @param {Either} eitherMonad\n * @return {Maybe}\n *\n * @example\n * import { eitherToMaybe, Either } from '@7urtle/lambda';\n *\n * eitherToMaybe(Either.Success('7urtle')); // => Just('7urtle')\n * eitherToMaybe(Either.Success(undefined)); // => Nothing\n * eitherToMaybe(Either.Failure('I am an error.')); // => Nothing\n * eitherToMaybe(Either.Failure('I am an error.')).value; // => 'I am an error.'\n */\nexport const eitherToMaybe = eitherMonad =>\n  either\n  (() => Nothing)\n  (value => Maybe.of(value))\n  (eitherMonad);\n\n/**\n * eitherToSyncEffect converts any Either monad to a SyncEffect monad with\n * error thrown on trigger if Either is Failure.\n *\n * @HindleyMilner eitherToSyncEffect :: Either -> SyncEffect\n *\n * @pure\n * @param {Either} eitherMonad\n * @return {SyncEffect}\n *\n * @example\n * import { eitherToSyncEffect, Either } from '@7urtle/lambda';\n *\n * eitherToSyncEffect(Either.Success('7urtle')).trigger(); // => '7urtle'\n * eitherToSyncEffect(Either.Failure('I am an error.')).trigger(); // throws 'I am an error.'\n */\nexport const eitherToSyncEffect = eitherMonad =>\n  either\n  (error => SyncEffect.of(() => { throw error; }))\n  (value => SyncEffect.of(() => value))\n  (eitherMonad);\n\n/**\n * eitherToAsyncEffect converts any Either monad to a AsyncEffect monad with\n * rejected error if Either is Failure.\n *\n * @HindleyMilner eitherToAsyncEffect :: Either -> AsyncEffect\n *\n * @pure\n * @param {Either} eitherMonad\n * @return {AsyncEffect}\n *\n * @example\n * import { eitherToAsyncEffect, Either } from '@7urtle/lambda';\n *\n * eitherToAsyncEffect(Either.Success('7urtle')); // resolves to '7urtle'\n * eitherToAsyncEffect(Either.Failure('I am an error.')); // rejects 'I am an error.'\n */\nexport const eitherToAsyncEffect = eitherMonad =>\n  either\n  (error => AsyncEffect.of(reject => _ => reject(error)))\n  (value => AsyncEffect.of(_ => resolve => resolve(value)))\n  (eitherMonad);","import { deepInspect } from './utils.js';\nimport { nary } from './arity.js';\nimport { isNothing } from './conditional.js';\nimport { reduce } from './list.js';\nimport { Failure, Success } from './Either.js';\nimport { SyncEffect } from './SyncEffect.js';\nimport { AsyncEffect } from './AsyncEffect.js';\n\nexport const Nothing = {\n  value: null,\n  inspect: () => 'Nothing',\n  isNothing: () => true,\n  isJust: () => false,\n  map: () => Nothing,\n  flatMap: () => Nothing,\n  ap: () => Nothing\n};\n\nexport const Just = value => ({\n  value: value,\n  inspect: () => `Just(${deepInspect(value)})`,\n  isNothing: () => false,\n  isJust: () => true,\n  map: fn => Maybe.of(fn(value)),\n  flatMap: fn => fn(value),\n  ap: f => f.map(value)\n});\n\n/**\n * Maybe is one of the simplest and well known monads. Maybe is also quite similar to our monad Either.\n *\n * Maybe expects a value as its input. It is Nothing if the value is null, undefined, or empty. It returns\n * Just for all other cases.\n *\n * Maybe is called Maybe because it maybe holds a value. You want to use Maybe for situations when you don't\n * know whether there is going to be an input. For example for your API endpoint, it makes it very obvious\n * that you service may not receive a value by mistake and forces the consumer of Maybe to safely deal with it.\n *\n * In other languages, Maybe monad can also be called Option monad or Nullable monad.\n *\n * @example\n * import {maybe, Maybe, Just, Nothing, upperCaseOf, liftA2, flatMap, compose, startsWith} from '@7urtle/lambda';\n *\n * // in the example we randomly give Maybe a value or undefined. Maybe.of() outputs an instance of Maybe.\n * const myMaybe = Maybe.of(Math.random() > 0.5 ? 'random success' : undefined);\n * \n * // you can use Just and Nothing directly\n * Just('7urtle') === Maybe.of('7urtle'); // => true\n * Just('7urte') === Maybe.Just('7urtle'); // => true\n * Nothing === Maybe.of(undefined); // => true\n * Nothing === Maybe.Nothing; // => true\n *\n * // you could access the actual value like this\n * myMaybe.value; // => 'random success' or undefined\n *\n * // you can also inspect it by\n * myMaybe.inspect(); // => \"Just('random success')\" or \"Nothing\"\n *\n * // you can check if the value is Nothing\n * myMaybe.isNothing(); // => true or false\n * Maybe.of('abc').isNothing(); // => false\n * Maybe.of([]).isNothing(); // => true\n * Just('7urtle').isNothing(); // => false\n * Nothing.isNothing(); // => true\n *\n * // you can check if the value is Just\n * myMaybe.isJust(); // => true or false\n * Maybe.of(123).isJust(); // => true\n * Maybe.of(null).isJust(); // => false\n * Just('7urtle').isJust(); // => true\n * Nothing.isJust(); // => false\n *\n * // as a functor the value inside is safely mappable (map doesn't execute over Nothing)\n * myMaybe.map(value => upperCaseOf(value));\n * myMaybe.inspect(); // => \"Just('RANDOM SUCCESS')\" or \"Nothing\"\n *\n * // as a monad Maybe can be safely flat mapped with other Maybes (flatMap doesn't execute over Nothing)\n * Maybe.of(3).flatMap(a => Maybe.of(a + 2)).inspect(); // => 'Just(5)'\n * Maybe.of(3).flatMap(a => Maybe.of(null)).inspect(); // => 'Nothing'\n * Maybe.of(3).flatMap(a => a + 2); // => 5\n *\n * // as an applicative functor you can apply Maybes to each other especially using liftA2 or liftA3\n * const add = a => b => a + b;\n * liftA2(add)(Maybe.of(2))(Maybe.of(3)); // => Just(5)\n * Maybe.of(1).map(add).ap(Maybe.of(2)).inspect(); // => 'Just(3)'\n * Maybe.of(1).map(add).ap(Maybe.of(null)).inspect(); // => 'Nothing'\n * Maybe.of(add).ap(Maybe.of(1)).ap(Maybe.of(2)).inspect(); // => 'Just(3)'\n *\n * // as an example you can use Maybe to help you work with DOM like this\n * Maybe.of(document.querySelector('#iexist')).map(a => a.offsetTop); // => Just(1240)\n * Maybe.of(document.querySelector('#idontexist')).map(a => a.offsetTop); // => Nothing\n * maybe\n * (() => 'error: the object doesnt exist')\n * (offsetTop => 'offset from top is ' + offsetTop)\n * (Maybe.of(document?.querySelector('#iexist')?.offsetTop));\n * \n * // to read API request you can use Maybe this way\n * const getQuery = body =>\n *   flatMap\n *   (a => Maybe.of(a.queryText))\n *   (Maybe.of(body.queryResult));\n * \n * // you can use Maybe, Just, and Nothing as output of your functions\n * const maybeGetEnvironmentVariable = key => Maybe.of(process?.env?[key]);\n * const maybeDIDKeyFromEnvironment =\n *   compose(\n *     flatMap(did => startsWith('did:key')(did) ? Just(did) : Nothing),\n *     maybeGetEnvironmentVariable\n *   );\n */\nexport const Maybe = {\n  of: value => isNothing(value) ? Nothing : Just(value),\n  Just: value => Just(value),\n  Nothing: Nothing\n};\n\n/**\n * maybe outputs result of a function onJust if input Maybe is Just or outputs input error if input Maybe is Nothing.\n *\n * maybe can be called both as a curried unary function or as a standard ternary function.\n *\n * @HindleyMilner maybe :: (a -> b) -> (c -> d) -> Maybe -> e\n *\n * @pure\n * @param {functioon} onNothing\n * @param {function} onJust\n * @param {Maybe} functorMaybe\n * @return {*}\n *\n * @example\n * import {maybe, Maybe} from '@7urtle/lambda';\n *\n * maybe(() => 'error')(value => value)(Maybe.of('abc')); // => 'abc'\n * maybe(() => 'error')(value => value)(Maybe.of(undefined)); // => 'error'\n * maybe(() => 'error')(() => 'not error)(Maybe.of(undefined)) === Maybe.of(undefined).isNothing() ? 'error' ? 'not error';\n *\n * // maybe can be called both as a curried unary function or as a standard ternary function\n * maybe(() => 'error')(value => value)(Maybe.of('abc')) === maybe('error', value => value, Maybe.of('abc'));\n */\nexport const maybe = nary(onNothing => onJust => functorMaybe =>\n  functorMaybe.isNothing()\n    ? onNothing()\n    : onJust(functorMaybe.value));\n\n/**\n * mergeMaybes outputs Maybe of array with all Maybe values depending whether they are Nothing or Just.\n *\n * @HindleyMilner mergeMaybes :: ([Maybe]) -> Maybe\n *\n * @pure\n * @param {Maybe} maybes\n * @return {Maybe}\n *\n * @example\n * import { mergeMaybes, Nothing, Just, Maybe } from '@7urtle/lambda';\n *\n * mergeMaybes(Maybe.of('abc'), Just('def')); //  => Just(['abc', 'def'])\n * mergeMaybes(Maybe.of('abc'), Nothing); // => Nothing\n * mergeMaybes(Nothing, Maybe.of('def')); // => Nothing\n * mergeMaybes(Nothing, Nothing); // => Nothing\n */\nexport const mergeMaybes = (...maybes) =>\n  reduce\n  (Just([]))\n  ((accumulator, current) =>\n    current.isNothing()\n    ? Nothing\n    : accumulator.isNothing()\n      ? Nothing\n      : Just([...accumulator.value, current.value])\n  )\n  (maybes);\n\n/**\n * maybeToEither converts any Maybe monad to an Either monad with\n * 'Maybe is Nothing.' Failure if the Maybe is Nothing.\n *\n * @HindleyMilner maybeToEither :: Maybe -> Either\n *\n * @pure\n * @param {Maybe} maybeMonad\n * @return {Either}\n *\n * @example\n * import { maybeToEither, Maybe } from '@7urtle/lambda';\n *\n * maybeToEither(Maybe.of('7urtle')); // => Success('7urtle')\n * maybeToEither(Maybe.of(undefined)); // => Failure('Maybe is Nothing.')\n */\nexport const maybeToEither = maybeMonad =>\n  maybe\n  (() => Failure('Maybe is Nothing.'))\n  (value => Success(value))\n  (maybeMonad);\n\n/**\n * maybeToSyncEffect converts any Maybe monad to an SyncEffect monad with\n * 'Maybe is Nothing.' thrown error if the Maybe is Nothing.\n *\n * @HindleyMilner maybeToSyncEffect :: Maybe -> SyncEffect\n *\n * @pure\n * @param {Maybe} maybeMonad\n * @return {SyncEffect}\n *\n * @example\n * import { maybeToSyncEffect, Maybe } from '@7urtle/lambda';\n *\n * maybeToSyncEffect(Maybe.of('7urtle')).trigger(); // => '7urtle'\n * maybeToSyncEffect(Maybe.of(undefined)).trigger(); // throws 'Maybe is Nothing.'\n */\nexport const maybeToSyncEffect = maybeMonad =>\n  maybe\n  (() => SyncEffect.of(() => { throw 'Maybe is Nothing.' }))\n  (value => SyncEffect.of(() => value))\n  (maybeMonad);\n\n/**\n * maybeToAsyncEffect converts any Maybe monad to an AsyncEffect monad with\n * 'Maybe is Nothing.' reject if the Maybe is Nothing.\n *\n * @HindleyMilner maybeToAsyncEffect :: Maybe -> AsyncEffect\n *\n * @pure\n * @param {Maybe} maybeMonad\n * @return {AsyncEffect}\n *\n * @example\n * import { maybeToAsyncEffect, Maybe } from '@7urtle/lambda';\n *\n * maybeToAsyncEffect(Maybe.of('7urtle')); // resolves to '7urtle'\n * maybeToAsyncEffect(Maybe.of(undefined)); // rejects 'Maybe is Nothing.'\n */\nexport const maybeToAsyncEffect = maybeMonad =>\n  maybe\n  (() => AsyncEffect.of(reject => _ => reject('Maybe is Nothing.')))\n  (value => AsyncEffect.of(_ => resolve => resolve(value)))\n  (maybeMonad);"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","nary","fn","args","length","reduce","accumulator","current","curry","args2","_arrayLikeToArray","arr","len","i","arr2","Array","_toConsumableArray","isArray","iter","iterator","from","minLen","n","toString","slice","constructor","name","test","TypeError","_typeof","and","predicates","anything","everyOf","predicate","or","someOf","isEqual","a","b","isNotEqual","isDeepEqual","deepInspect","isNotDeepEqual","isTrue","isFalse","isGreaterThan","isLessThan","isAtLeast","isAtMost","isBetween","c","isInRange","isTypeOf","typeOf","isNotTypeOf","isString","isNotString","isBoolean","isNotBoolean","isNull","isNotNull","isUndefined","isNotUndefined","isNumber","isNotNumber","isObject","isNotObject","isNotArray","isFunction","isNotFunction","isLength","lengthOf","isNotLength","isElement","Element","HTMLDocument","isNotElement","isEmpty","getOwnPropertyNames","isNotEmpty","isZero","isNotZero","isNothing","isJust","when","whenTrueFn","unless","whenFalseFn","ifElse","_defineProperty","configurable","writable","identity","compose","fns","reduceRight","v","f","pipe","map","mapper","flatMap","functor","liftA2","ap1","ap2","ap","liftA3","ap3","concat","undefined","merge","sources","acc","includes","indexOf","minusOneToUndefined","lastIndexOf","memoize","memory","passThrough","memo","fail","error","log","console","spy","inspectFunction","String","inspectArray","join","inspectString","inspectObject","inspect","k","keysOf","trim","string","testRegEx","regex","substr","limit","start","firstLetterOf","lastLetterOf","startsWith","substring","endsWith","repeat","count","replace","replacement","search","split","lowerCaseOf","toLowerCase","upperCaseOf","toUpperCase","initial","reducer","list","filter","checker","filterMap","push","find","findIndex","separator","keys","entriesOf","entries","every","end","some","sort","compare","sortAlphabetically","sortAlphabeticallyZA","sortNumerically","sortNumerically21","headOf","tailOf","initOf","lastOf","groupBy","randomOf","Math","floor","random","Case","of","match","getCase","Map","result","AsyncEffect","trigger","getAsyncEffect","reject","resolve","ofPromise","promise","then","Promise","x","mergeAsyncEffects","asyncEffects","all","SyncEffect","getSyncEffect","syncEffectToMaybe","syncEffectMonad","Maybe","Nothing","syncEffectToEither","Either","syncEffectToAsyncEffect","_","Failure","isFailure","isSuccess","catchMap","bimap","leftFn","orOf","Success","orElse","orTry","rightFn","m","try","message","either","onFailure","onSuccess","functorEither","mergeEithers","eithers","validateEithers","input","currentFn","currentResult","eitherToMaybe","eitherMonad","eitherToSyncEffect","eitherToAsyncEffect","Just","maybe","onNothing","onJust","functorMaybe","mergeMaybes","maybes","maybeToEither","maybeMonad","maybeToSyncEffect","maybeToAsyncEffect"],"sourceRoot":""}